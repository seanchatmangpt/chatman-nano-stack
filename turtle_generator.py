#!/usr/bin/env python3
"""
Turtle Generator - Converts 80/20 optimized models to RDF Turtle format
Bridges between the 80/20 Typer and ttl2dspy
"""

import re
from datetime import datetime
from typing import Dict, List, Set, Optional, Any
from pathlib import Path
import rdflib
from rdflib import Graph, Namespace, URIRef, Literal, RDF, RDFS, OWL, SH, XSD

from eighty_twenty_typer import SemanticModel, SemanticType, SemanticRelationship


class TurtleGenerator:
    """Generates W3C standard RDF Turtle from optimized semantic models"""
    
    def __init__(self, base_uri: str = "http://cns.io/ontology#"):
        self.base_uri = base_uri
        self.namespace = Namespace(base_uri)
        self.prefixes = {
            "": base_uri,
            "owl": str(OWL),
            "rdfs": str(RDFS),
            "rdf": str(RDF),
            "sh": str(SH),
            "xsd": str(XSD)
        }
    
    def generate_turtle(self, model: SemanticModel, include_shacl: bool = True) -> str:
        """Generate complete TTL with ontology and optional SHACL shapes"""
        graph = Graph()
        
        # Bind prefixes
        for prefix, uri in self.prefixes.items():
            graph.bind(prefix, uri)
        
        # Add ontology metadata
        self._add_ontology_metadata(graph, model)
        
        # Add classes
        for semantic_type in model.types:
            self._add_class(graph, semantic_type)
        
        # Add properties from relationships
        properties_added = set()
        for relationship in model.relationships:
            prop_uri = self._add_property(graph, relationship, properties_added)
        
        # Add SHACL shapes if requested
        if include_shacl:
            for semantic_type in model.types:
                self._add_shacl_shape(graph, semantic_type, model.relationships)
        
        # Serialize to Turtle
        return graph.serialize(format='turtle')
    
    def _add_ontology_metadata(self, graph: Graph, model: SemanticModel):
        """Add ontology-level metadata"""
        onto_uri = URIRef(self.base_uri[:-1])  # Remove trailing #
        graph.add((onto_uri, RDF.type, OWL.Ontology))
        graph.add((onto_uri, RDFS.label, Literal("CNS 80/20 Optimized Ontology")))
        graph.add((onto_uri, RDFS.comment, Literal(
            f"Generated by 80/20 optimization. Original: {model.metadata.get('optimization', {}).get('original_type_count', 'N/A')} types, "
            f"Optimized: {len(model.types)} types"
        )))
        graph.add((onto_uri, OWL.versionInfo, Literal(datetime.now().isoformat())))
    
    def _add_class(self, graph: Graph, semantic_type: SemanticType):
        """Add a class definition"""
        class_uri = URIRef(self.base_uri + semantic_type.name)
        
        # Basic class declaration
        graph.add((class_uri, RDF.type, OWL.Class))
        graph.add((class_uri, RDFS.label, Literal(semantic_type.name)))
        
        # Add comment with attributes if any
        if semantic_type.attributes:
            comment = f"Attributes: {', '.join(semantic_type.attributes)}"
            if semantic_type.constraints:
                comment += f"; Constraints: {', '.join(semantic_type.constraints)}"
            graph.add((class_uri, RDFS.comment, Literal(comment)))
        
        # Add usage score as annotation
        if hasattr(semantic_type, 'usage_score'):
            score_prop = URIRef(self.base_uri + "usageScore")
            graph.add((score_prop, RDF.type, OWL.AnnotationProperty))
            graph.add((class_uri, score_prop, Literal(semantic_type.usage_score, datatype=XSD.float)))
    
    def _add_property(self, graph: Graph, relationship: SemanticRelationship, 
                     properties_added: Set[str]) -> URIRef:
        """Add a property definition"""
        prop_name = relationship.predicate
        prop_uri = URIRef(self.base_uri + prop_name)
        
        # Only add if not already added
        if prop_name not in properties_added:
            graph.add((prop_uri, RDF.type, OWL.ObjectProperty))
            graph.add((prop_uri, RDFS.label, Literal(prop_name)))
            
            # Add domain and range
            source_uri = URIRef(self.base_uri + relationship.source)
            target_uri = URIRef(self.base_uri + relationship.target)
            graph.add((prop_uri, RDFS.domain, source_uri))
            graph.add((prop_uri, RDFS.range, target_uri))
            
            # Add cardinality info as comment
            if relationship.cardinality:
                graph.add((prop_uri, RDFS.comment, Literal(f"Cardinality: {relationship.cardinality}")))
            
            properties_added.add(prop_name)
        
        return prop_uri
    
    def _add_shacl_shape(self, graph: Graph, semantic_type: SemanticType, 
                        relationships: List[SemanticRelationship]):
        """Add SHACL shape for validation"""
        shape_uri = URIRef(self.base_uri + semantic_type.name + "Shape")
        class_uri = URIRef(self.base_uri + semantic_type.name)
        
        # Basic shape
        graph.add((shape_uri, RDF.type, SH.NodeShape))
        graph.add((shape_uri, SH.targetClass, class_uri))
        graph.add((shape_uri, RDFS.label, Literal(f"{semantic_type.name} Shape")))
        
        # Add attribute properties
        for i, attr in enumerate(semantic_type.attributes):
            prop_shape = URIRef(f"{shape_uri}_prop{i}")
            graph.add((shape_uri, SH.property, prop_shape))
            
            # Property shape details
            graph.add((prop_shape, SH.path, URIRef(self.base_uri + attr)))
            graph.add((prop_shape, SH.datatype, XSD.string))  # Default to string
            graph.add((prop_shape, SH.maxCount, Literal(1)))
            graph.add((prop_shape, SH.name, Literal(attr)))
        
        # Add relationship constraints
        for rel in relationships:
            if rel.source == semantic_type.name:
                rel_shape = URIRef(f"{shape_uri}_rel_{rel.predicate}")
                graph.add((shape_uri, SH.property, rel_shape))
                
                graph.add((rel_shape, SH.path, URIRef(self.base_uri + rel.predicate)))
                graph.add((rel_shape, SH['class'], URIRef(self.base_uri + rel.target)))
                
                # Cardinality constraints
                if rel.required:
                    graph.add((rel_shape, SH.minCount, Literal(1)))
                
                if rel.cardinality == "one-to-one":
                    graph.add((rel_shape, SH.maxCount, Literal(1)))
    
    def save_turtle(self, model: SemanticModel, output_path: str, include_shacl: bool = True):
        """Generate and save Turtle to file"""
        ttl_content = self.generate_turtle(model, include_shacl)
        Path(output_path).write_text(ttl_content)
        print(f"✅ Generated Turtle file: {output_path}")
        return output_path


def connect_to_ttl2dspy(turtle_file: str) -> str:
    """Connect generated Turtle to ttl2dspy for DSPy signature generation"""
    import subprocess
    import sys
    
    # Run ttl2dspy on the generated turtle file
    output_file = turtle_file.replace('.ttl', '_signatures.py')
    
    try:
        result = subprocess.run([
            sys.executable, 
            "hyperintel-ttl2dspy/ttl2dspy.py",
            turtle_file,
            "-o", output_file
        ], capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"✅ Generated DSPy signatures: {output_file}")
            return output_file
        else:
            print(f"❌ ttl2dspy error: {result.stderr}")
            raise Exception(f"ttl2dspy failed: {result.stderr}")
            
    except FileNotFoundError:
        print("❌ ttl2dspy not found. Make sure hyperintel-ttl2dspy/ttl2dspy.py exists")
        raise


if __name__ == "__main__":
    # Example integration test
    from eighty_twenty_typer import SemanticModel, SemanticType, SemanticRelationship
    
    # Create sample model (would come from 80/20 typer)
    model = SemanticModel(
        types=[
            SemanticType("MarketData", "http://cns.io/MarketData", 
                        ["symbol", "price", "volume", "timestamp"]),
            SemanticType("Order", "http://cns.io/Order",
                        ["id", "type", "quantity", "price"]),
            SemanticType("Position", "http://cns.io/Position",
                        ["symbol", "quantity", "avgPrice"])
        ],
        relationships=[
            SemanticRelationship("Order", "MarketData", "basedOn", required=True),
            SemanticRelationship("Position", "Order", "createdFrom", required=True)
        ]
    )
    
    # Generate Turtle
    generator = TurtleGenerator()
    generator.save_turtle(model, "test_output.ttl")
    
    # Connect to ttl2dspy
    try:
        signatures = connect_to_ttl2dspy("test_output.ttl")
        print(f"✅ Pipeline connected: 80/20 → Turtle → ttl2dspy")
    except Exception as e:
        print(f"❌ Pipeline connection failed: {e}")