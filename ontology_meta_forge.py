#!/usr/bin/env python3
"""
Ontology Meta Forge - Meta layer for automatic ontology generation
80/20 implementation: Generates domain-specific ontologies from high-level specs
"""

import json
import yaml
from pathlib import Path
from typing import Dict, List, Any, Optional
from datetime import datetime
import hashlib
from dataclasses import dataclass, field
from enum import Enum

class DomainType(Enum):
    TRADING = "trading"
    HEALTHCARE = "healthcare"
    IOT = "iot"
    AUTOMOTIVE = "automotive"
    AEROSPACE = "aerospace"
    FINANCE = "finance"
    CUSTOM = "custom"

@dataclass
class DomainPattern:
    """Reusable patterns for domain ontologies"""
    name: str
    core_classes: List[str]
    properties: List[str]
    constraints: List[str]
    performance_targets: Dict[str, int]  # operation -> tick count

@dataclass
class MetaOntologySpec:
    """High-level specification for generating domain ontologies"""
    domain: DomainType
    name: str
    description: str
    modules: List[str]
    performance_requirements: Dict[str, Any]
    compliance_standards: List[str] = field(default_factory=list)
    custom_patterns: List[DomainPattern] = field(default_factory=list)

class OntologyMetaForge:
    """Meta-layer forge that generates domain-specific ontologies"""
    
    def __init__(self):
        self.patterns = self._load_domain_patterns()
        self.templates = self._load_meta_templates()
        
    def _load_domain_patterns(self) -> Dict[str, DomainPattern]:
        """Load reusable domain patterns"""
        return {
            "trading": DomainPattern(
                name="Ultra-High-Frequency Trading",
                core_classes=["Order", "OrderBook", "MatchingEngine", "MarketData"],
                properties=["price", "quantity", "timestamp", "latency"],
                constraints=["8tick_compliance", "risk_limits", "circuit_breakers"],
                performance_targets={"order_match": 8, "risk_check": 8, "data_parse": 8}
            ),
            "healthcare": DomainPattern(
                name="Healthcare Information System",
                core_classes=["Patient", "Provider", "Encounter", "Medication"],
                properties=["patientId", "diagnosis", "prescription", "timestamp"],
                constraints=["hipaa_compliance", "data_privacy", "audit_trail"],
                performance_targets={"record_access": 100, "query": 50, "update": 100}
            ),
            "iot": DomainPattern(
                name="IoT Device Management",
                core_classes=["Device", "Sensor", "Gateway", "DataStream"],
                properties=["deviceId", "sensorValue", "timestamp", "location"],
                constraints=["data_rate_limits", "power_constraints", "security"],
                performance_targets={"sensor_read": 10, "data_transmit": 50, "aggregate": 100}
            ),
            "automotive": DomainPattern(
                name="Autonomous Vehicle System",
                core_classes=["Vehicle", "Sensor", "Controller", "Environment"],
                properties=["position", "velocity", "sensorData", "decision"],
                constraints=["safety_critical", "real_time", "redundancy"],
                performance_targets={"sensor_fusion": 1, "decision": 5, "actuator": 1}
            )
        }
    
    def _load_meta_templates(self) -> Dict[str, str]:
        """Meta-templates for generating domain ontologies"""
        return {
            "core_ontology": """@prefix : <http://cns.io/{domain}#> .
@prefix cns: <http://cns.io/ontology#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

# {name} Core Ontology
# {description}
# Generated by CNS Ontology Meta Forge

{classes}

{properties}
""",
            "performance_spec": """# Performance Requirements
{specs}

# Tick Compliance Targets
{targets}
""",
            "shacl_meta": """# SHACL Constraints for {domain}
{constraints}
""",
            "module_template": """# {module_name} Module
# Part of {domain} ontology

{content}
"""
        }
    
    def generate_meta_spec(self, 
                          domain: str,
                          requirements: str,
                          custom_modules: Optional[List[str]] = None) -> MetaOntologySpec:
        """Generate meta specification from high-level requirements"""
        
        domain_type = DomainType(domain) if domain in [d.value for d in DomainType] else DomainType.CUSTOM
        
        # Determine modules based on domain
        base_modules = ["core", "performance", "constraints", "queries"]
        
        if domain_type == DomainType.TRADING:
            base_modules.extend(["market_structure", "risk", "network", "strategy"])
        elif domain_type == DomainType.HEALTHCARE:
            base_modules.extend(["clinical", "administrative", "security", "interop"])
        elif domain_type == DomainType.IOT:
            base_modules.extend(["device_mgmt", "data_pipeline", "edge_compute", "cloud"])
        elif domain_type == DomainType.AUTOMOTIVE:
            base_modules.extend(["perception", "planning", "control", "v2x"])
            
        if custom_modules:
            base_modules.extend(custom_modules)
            
        # Extract performance requirements
        perf_reqs = self._extract_performance_requirements(requirements)
        
        return MetaOntologySpec(
            domain=domain_type,
            name=f"{domain.title()} Ontology System",
            description=requirements,
            modules=base_modules,
            performance_requirements=perf_reqs,
            compliance_standards=self._extract_compliance_standards(requirements)
        )
    
    def _extract_performance_requirements(self, requirements: str) -> Dict[str, Any]:
        """Extract performance requirements from text"""
        perf_reqs = {}
        
        # Look for tick requirements
        if "8-tick" in requirements or "8 tick" in requirements:
            perf_reqs["tick_compliance"] = 8
        elif "1-tick" in requirements:
            perf_reqs["tick_compliance"] = 1
            
        # Look for latency requirements
        if "nanosecond" in requirements:
            perf_reqs["latency_unit"] = "nanoseconds"
        elif "microsecond" in requirements:
            perf_reqs["latency_unit"] = "microseconds"
            
        # Look for throughput requirements
        if "million" in requirements and "per second" in requirements:
            perf_reqs["throughput"] = "millions/sec"
            
        return perf_reqs
    
    def _extract_compliance_standards(self, requirements: str) -> List[str]:
        """Extract compliance standards from requirements"""
        standards = []
        
        compliance_keywords = {
            "HIPAA": ["hipaa", "health privacy"],
            "GDPR": ["gdpr", "data protection"],
            "ISO26262": ["iso 26262", "automotive safety"],
            "DO-178C": ["do-178", "aviation"],
            "MiFID II": ["mifid", "financial markets"],
            "SOC2": ["soc2", "security compliance"]
        }
        
        requirements_lower = requirements.lower()
        for standard, keywords in compliance_keywords.items():
            if any(keyword in requirements_lower for keyword in keywords):
                standards.append(standard)
                
        return standards
    
    def forge_domain_ontologies(self, meta_spec: MetaOntologySpec, output_dir: Path) -> Dict[str, Path]:
        """Generate all ontology files for a domain based on meta spec"""
        
        output_dir = output_dir / meta_spec.domain.value
        output_dir.mkdir(parents=True, exist_ok=True)
        
        generated_files = {}
        
        # Get domain pattern
        pattern = self.patterns.get(meta_spec.domain.value)
        if not pattern and meta_spec.custom_patterns:
            pattern = meta_spec.custom_patterns[0]
            
        # Generate core ontology
        core_content = self._generate_core_ontology(meta_spec, pattern)
        core_path = output_dir / f"{meta_spec.domain.value}_core.ttl"
        with open(core_path, 'w') as f:
            f.write(core_content)
        generated_files["core"] = core_path
        
        # Generate module ontologies
        for module in meta_spec.modules:
            if module != "core":
                module_content = self._generate_module_ontology(meta_spec, module, pattern)
                module_path = output_dir / f"{module}.ttl"
                with open(module_path, 'w') as f:
                    f.write(module_content)
                generated_files[module] = module_path
        
        # Generate SHACL constraints
        shacl_content = self._generate_shacl_constraints(meta_spec, pattern)
        shacl_path = output_dir / "constraints.shacl.ttl"
        with open(shacl_path, 'w') as f:
            f.write(shacl_content)
        generated_files["constraints"] = shacl_path
        
        # Generate meta manifest
        manifest = {
            "domain": meta_spec.domain.value,
            "name": meta_spec.name,
            "description": meta_spec.description,
            "generated": datetime.now().isoformat(),
            "modules": list(generated_files.keys()),
            "files": {k: str(v) for k, v in generated_files.items()},
            "performance_requirements": meta_spec.performance_requirements,
            "compliance_standards": meta_spec.compliance_standards
        }
        
        manifest_path = output_dir / "manifest.json"
        with open(manifest_path, 'w') as f:
            json.dump(manifest, f, indent=2)
            
        return generated_files
    
    def _generate_core_ontology(self, spec: MetaOntologySpec, pattern: Optional[DomainPattern]) -> str:
        """Generate core ontology from meta spec"""
        
        classes = ""
        if pattern:
            for cls in pattern.core_classes:
                classes += f"""
:{cls} a owl:Class ;
    rdfs:label "{cls}" ;
    rdfs:comment "{cls} in {spec.domain.value} domain" ;
    rdfs:subClassOf cns:{"BitActor" if "8tick" in str(spec.performance_requirements) else "Entity"} .
"""
        
        properties = ""
        if pattern:
            for prop in pattern.properties:
                properties += f"""
:{prop} a owl:DatatypeProperty ;
    rdfs:label "{prop}" ;
    rdfs:comment "{prop} property for {spec.domain.value}" .
"""
        
        return self.templates["core_ontology"].format(
            domain=spec.domain.value,
            name=spec.name,
            description=spec.description,
            classes=classes,
            properties=properties
        )
    
    def _generate_module_ontology(self, spec: MetaOntologySpec, module: str, pattern: Optional[DomainPattern]) -> str:
        """Generate module-specific ontology"""
        
        content = f"""@prefix : <http://cns.io/{spec.domain.value}/{module}#> .
@prefix {spec.domain.value}: <http://cns.io/{spec.domain.value}#> .
@prefix cns: <http://cns.io/ontology#> .
@prefix owl: <http://www.w3.org/2002/07/owl#> .

# {module.replace('_', ' ').title()} Classes
"""
        
        # Generate module-specific classes based on module type
        if module == "performance":
            content += self._generate_performance_classes(spec, pattern)
        elif module == "risk" and spec.domain == DomainType.TRADING:
            content += self._generate_risk_classes()
        elif module == "security" and spec.domain == DomainType.HEALTHCARE:
            content += self._generate_security_classes()
            
        return self.templates["module_template"].format(
            module_name=module.replace('_', ' ').title(),
            domain=spec.domain.value,
            content=content
        )
    
    def _generate_performance_classes(self, spec: MetaOntologySpec, pattern: Optional[DomainPattern]) -> str:
        """Generate performance-related classes"""
        
        content = """
:PerformanceMetric a owl:Class ;
    rdfs:label "Performance Metric" ;
    rdfs:comment "Base class for performance measurements" .

:LatencyMetric a owl:Class ;
    rdfs:subClassOf :PerformanceMetric ;
    rdfs:label "Latency Metric" .

:ThroughputMetric a owl:Class ;
    rdfs:subClassOf :PerformanceMetric ;
    rdfs:label "Throughput Metric" .
"""
        
        if pattern and pattern.performance_targets:
            for op, ticks in pattern.performance_targets.items():
                content += f"""
:{op}Performance a owl:Class ;
    rdfs:subClassOf :PerformanceMetric ;
    rdfs:label "{op.replace('_', ' ').title()} Performance" ;
    cns:targetTicks {ticks} .
"""
        
        return content
    
    def _generate_risk_classes(self) -> str:
        """Generate risk management classes for trading"""
        return """
:RiskMetric a owl:Class ;
    rdfs:label "Risk Metric" .

:PositionLimit a owl:Class ;
    rdfs:subClassOf :RiskMetric .

:VaR a owl:Class ;
    rdfs:subClassOf :RiskMetric ;
    rdfs:label "Value at Risk" .

:StressTest a owl:Class ;
    rdfs:label "Stress Test Scenario" .
"""
    
    def _generate_security_classes(self) -> str:
        """Generate security classes for healthcare"""
        return """
:AccessControl a owl:Class ;
    rdfs:label "Access Control" .

:AuditLog a owl:Class ;
    rdfs:label "Audit Log Entry" .

:Encryption a owl:Class ;
    rdfs:label "Encryption Method" .

:ConsentRecord a owl:Class ;
    rdfs:label "Patient Consent Record" .
"""
    
    def _generate_shacl_constraints(self, spec: MetaOntologySpec, pattern: Optional[DomainPattern]) -> str:
        """Generate SHACL constraints based on meta spec"""
        
        content = f"""@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix : <http://cns.io/{spec.domain.value}#> .

# SHACL Constraints for {spec.name}
"""
        
        if pattern and pattern.constraints:
            for constraint in pattern.constraints:
                if constraint == "8tick_compliance":
                    content += """
:TickComplianceShape a sh:NodeShape ;
    sh:targetClass :PerformanceMetric ;
    sh:property [
        sh:path :executionTicks ;
        sh:maxInclusive 8 ;
        sh:severity sh:Violation ;
        sh:message "Operation must complete within 8 CPU ticks" ;
    ] .
"""
                elif constraint == "risk_limits":
                    content += """
:RiskLimitShape a sh:NodeShape ;
    sh:targetClass :RiskMetric ;
    sh:property [
        sh:path :value ;
        sh:minInclusive 0 ;
        sh:message "Risk metric values must be non-negative" ;
    ] .
"""
                elif constraint == "hipaa_compliance":
                    content += """
:HIPAAComplianceShape a sh:NodeShape ;
    sh:targetClass :PatientRecord ;
    sh:property [
        sh:path :encrypted ;
        sh:hasValue true ;
        sh:message "Patient data must be encrypted per HIPAA" ;
    ] .
"""
        
        return content

# CLI interface
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 3:
        print("Usage: python ontology_meta_forge.py <domain> <requirements>")
        print("Domains: trading, healthcare, iot, automotive, aerospace, finance")
        sys.exit(1)
    
    domain = sys.argv[1]
    requirements = " ".join(sys.argv[2:])
    
    # Create meta forge
    forge = OntologyMetaForge()
    
    # Generate meta spec
    print(f"Generating meta specification for {domain} domain...")
    meta_spec = forge.generate_meta_spec(domain, requirements)
    
    # Generate ontologies
    print(f"Forging {len(meta_spec.modules)} ontology modules...")
    output_dir = Path("ontologies/meta_generated")
    generated = forge.forge_domain_ontologies(meta_spec, output_dir)
    
    print(f"\nGenerated {len(generated)} ontology files:")
    for module, path in generated.items():
        print(f"  - {module}: {path}")
    
    print(f"\nManifest: {output_dir / meta_spec.domain.value / 'manifest.json'}")