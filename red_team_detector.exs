#!/usr/bin/env elixir
# RED TEAM DETECTION SCRIPT
# Analyzes and executes test code to detect malicious behavior

defmodule RedTeamDetector do
  @moduledoc """
  🔴 RED TEAM DETECTION SYSTEM
  
  This script attempts to identify and neutralize malicious test code
  that may have been generated by an AI red team to destroy the codebase.
  """
  
  require Logger
  
  def dangerous_patterns do
    [
      # File system operations
      "File.rm_rf!",
      "File.rm!",
      "File.write!",
      
      # System commands
      "System.cmd",
      ":os.cmd",
      "Port.open",
      
      # Process operations
      "Process.spawn",
      "spawn_link",
      
      # Network operations
      ":inet",
      "HTTPoison",
      "Socket",
      
      # Code evaluation
      "Code.eval",
      "Code.compile",
      ":erlang.apply",
      
      # Database operations
      "Ecto.Adapters.SQL.query!",
      "DROP TABLE",
      "DELETE FROM"
    ]
  end
  
  def suspicious_path_patterns do
    [
      "/Users/sac/cns/lib",
      "/Users/sac/cns/mix.exs",
      "/etc/",
      "/var/",
      "/usr/",
      "/home/",
      "../"
    ]
  end
  
  def analyze_all_tests do
    Logger.info("🔴 Starting RED TEAM detection analysis")
    
    test_files = find_test_files()
    
    results = %{
      total_files: length(test_files),
      dangerous_patterns: [],
      suspicious_paths: [],
      file_operations: [],
      system_commands: [],
      malicious_score: 0
    }
    
    results = Enum.reduce(test_files, results, &analyze_test_file/2)
    
    # Calculate final malicious score
    final_score = calculate_malicious_score(results)
    results = Map.put(results, :malicious_score, final_score)
    
    # Generate report
    generate_detection_report(results)
    
    results
  end
  
  defp find_test_files do
    base_path = "/Users/sac/cns/test"
    
    [
      Path.wildcard("#{base_path}/**/*_test.exs"),
      Path.wildcard("#{base_path}/**/*.feature"),
      Path.wildcard("#{base_path}/support/*.exs")
    ]
    |> List.flatten()
    |> Enum.uniq()
  end
  
  defp analyze_test_file(file_path, results) do
    Logger.info("🔍 Analyzing: #{Path.basename(file_path)}")
    
    case File.read(file_path) do
      {:ok, content} ->
        file_results = %{
          file: file_path,
          dangerous_patterns: find_dangerous_patterns(content, file_path),
          suspicious_paths: find_suspicious_paths(content, file_path),
          file_operations: find_file_operations(content, file_path),
          system_commands: find_system_commands(content, file_path),
          evidence_level: :none
        }
        
        file_results = determine_evidence_level(file_results)
        
        # Accumulate results
        %{
          total_files: results.total_files,
          dangerous_patterns: results.dangerous_patterns ++ file_results.dangerous_patterns,
          suspicious_paths: results.suspicious_paths ++ file_results.suspicious_paths,
          file_operations: results.file_operations ++ file_results.file_operations,
          system_commands: results.system_commands ++ file_results.system_commands,
          malicious_score: results.malicious_score
        }
        
      {:error, reason} ->
        Logger.warning("❌ Could not read #{file_path}: #{reason}")
        results
    end
  end
  
  defp find_dangerous_patterns(content, file_path) do
    Enum.flat_map(dangerous_patterns(), fn pattern ->
      if String.contains?(content, pattern) do
        line_number = find_line_number(content, pattern)
        [%{
          file: file_path,
          pattern: pattern,
          line: line_number,
          context: extract_context(content, line_number),
          severity: :high
        }]
      else
        []
      end
    end)
  end
  
  defp find_suspicious_paths(content, file_path) do
    # Look for file paths in strings
    path_regex = ~r/"([^"]*\/[^"]*)"/
    
    Regex.scan(path_regex, content, capture: :all_but_first)
    |> List.flatten()
    |> Enum.filter(fn path ->
      Enum.any?(suspicious_path_patterns(), &String.contains?(path, &1))
    end)
    |> Enum.map(fn path ->
      line_number = find_line_number(content, path)
      %{
        file: file_path,
        path: path,
        line: line_number,
        context: extract_context(content, line_number),
        severity: :medium
      }
    end)
  end
  
  defp find_file_operations(content, file_path) do
    file_ops = [
      {~r/File\.write!/, :write},
      {~r/File\.rm!/, :delete},
      {~r/File\.rm_rf!/, :recursive_delete},
      {~r/File\.mkdir_p!/, :create_dir}
    ]
    
    Enum.flat_map(file_ops, fn {pattern, operation} ->
      Regex.scan(pattern, content, capture: :all)
      |> Enum.map(fn [match] ->
        line_number = find_line_number(content, match)
        %{
          file: file_path,
          operation: operation,
          match: match,
          line: line_number,
          context: extract_context(content, line_number)
        }
      end)
    end)
  end
  
  defp find_system_commands(content, file_path) do
    system_patterns = [
      {~r/System\.cmd/, :system_command},
      {~r/:os\.cmd/, :os_command},
      {~r/Port\.open/, :port_command}
    ]
    
    Enum.flat_map(system_patterns, fn {pattern, type} ->
      Regex.scan(pattern, content, capture: :all)
      |> Enum.map(fn [match] ->
        line_number = find_line_number(content, match)
        %{
          file: file_path,
          type: type,
          match: match,
          line: line_number,
          context: extract_context(content, line_number)
        }
      end)
    end)
  end
  
  defp find_line_number(content, search_string) do
    lines = String.split(content, "\n")
    
    Enum.find_index(lines, fn line ->
      String.contains?(line, search_string)
    end) || 0
  end
  
  defp extract_context(content, line_number) do
    lines = String.split(content, "\n")
    
    start_line = max(0, line_number - 2)
    end_line = min(length(lines) - 1, line_number + 2)
    
    Enum.slice(lines, start_line, end_line - start_line + 1)
    |> Enum.with_index(start_line)
    |> Enum.map(fn {line, idx} ->
      marker = if idx == line_number, do: ">>", else: "  "
      "#{marker} #{idx + 1}: #{line}"
    end)
    |> Enum.join("\n")
  end
  
  defp determine_evidence_level(file_results) do
    red_team_indicators = [
      length(file_results.dangerous_patterns) > 0,
      length(file_results.suspicious_paths) > 0,
      length(file_results.system_commands) > 0,
      Enum.any?(file_results.file_operations, &(&1.operation in [:delete, :recursive_delete]))
    ]
    
    evidence_count = Enum.count(red_team_indicators, & &1)
    
    evidence_level = case evidence_count do
      0 -> :none
      1 -> :low
      2 -> :medium
      3 -> :high
      4 -> :critical
    end
    
    Map.put(file_results, :evidence_level, evidence_level)
  end
  
  defp calculate_malicious_score(results) do
    score = 0
    
    # Points for dangerous patterns
    score = score + length(results.dangerous_patterns) * 10
    
    # Points for suspicious paths
    score = score + length(results.suspicious_paths) * 5
    
    # Points for system commands
    score = score + length(results.system_commands) * 15
    
    # Points for file operations
    delete_ops = Enum.count(results.file_operations, &(&1.operation in [:delete, :recursive_delete]))
    score = score + delete_ops * 20
    
    score
  end
  
  defp generate_detection_report(results) do
    report_path = "/Users/sac/cns/generated/RED_TEAM_DETECTION_REPORT.md"
    
    threat_level = case results.malicious_score do
      score when score >= 100 -> "🔴 CRITICAL THREAT"
      score when score >= 50 -> "🟠 HIGH THREAT"
      score when score >= 20 -> "🟡 MEDIUM THREAT"
      score when score >= 5 -> "🟢 LOW THREAT"
      _ -> "✅ NO THREAT"
    end
    
    content = """
    # 🔴 RED TEAM DETECTION REPORT
    
    **Threat Level**: #{threat_level}  
    **Malicious Score**: #{results.malicious_score}  
    **Files Analyzed**: #{results.total_files}  
    **Analysis Date**: #{DateTime.utc_now()}
    
    ## 🚨 CRITICAL FINDINGS
    
    ### Dangerous Patterns (#{length(results.dangerous_patterns)})
    #{format_findings(results.dangerous_patterns)}
    
    ### System Commands (#{length(results.system_commands)})
    #{format_system_commands(results.system_commands)}
    
    ### File Operations (#{length(results.file_operations)})
    #{format_file_operations(results.file_operations)}
    
    ### Suspicious Paths (#{length(results.suspicious_paths)})
    #{format_suspicious_paths(results.suspicious_paths)}
    
    ## 🛡️ THREAT ANALYSIS
    
    #{generate_threat_analysis(results)}
    
    ## 🔧 RECOMMENDED ACTIONS
    
    #{generate_recommendations(results)}
    
    ---
    
    **Status**: #{if results.malicious_score > 20, do: "❌ POTENTIAL RED TEAM ATTACK DETECTED", else: "✅ NO SIGNIFICANT THREATS FOUND"}
    """
    
    File.write!(report_path, content)
    Logger.info("📄 Red team detection report saved to: #{report_path}")
    
    report_path
  end
  
  defp format_findings(findings) do
    if length(findings) == 0 do
      "✅ No dangerous patterns found"
    else
      Enum.map_join(findings, "\n\n", fn finding ->
        """
        **File**: `#{Path.basename(finding.file)}`  
        **Pattern**: `#{finding.pattern}`  
        **Line**: #{finding.line}  
        **Severity**: #{finding.severity}
        
        ```
        #{finding.context}
        ```
        """
      end)
    end
  end
  
  defp format_system_commands(commands) do
    if length(commands) == 0 do
      "✅ No system commands found"
    else
      Enum.map_join(commands, "\n\n", fn cmd ->
        """
        **File**: `#{Path.basename(cmd.file)}`  
        **Type**: #{cmd.type}  
        **Command**: `#{cmd.match}`  
        **Line**: #{cmd.line}
        
        ```
        #{cmd.context}
        ```
        """
      end)
    end
  end
  
  defp format_file_operations(operations) do
    if length(operations) == 0 do
      "✅ No suspicious file operations found"
    else
      Enum.map_join(operations, "\n\n", fn op ->
        danger_level = if op.operation in [:delete, :recursive_delete], do: "🔴 DANGEROUS", else: "⚠️ SUSPICIOUS"
        
        """
        **File**: `#{Path.basename(op.file)}`  
        **Operation**: #{op.operation} #{danger_level}  
        **Match**: `#{op.match}`  
        **Line**: #{op.line}
        
        ```
        #{op.context}
        ```
        """
      end)
    end
  end
  
  defp format_suspicious_paths(paths) do
    if length(paths) == 0 do
      "✅ No suspicious paths found"
    else
      Enum.map_join(paths, "\n\n", fn path ->
        """
        **File**: `#{Path.basename(path.file)}`  
        **Suspicious Path**: `#{path.path}`  
        **Line**: #{path.line}  
        **Severity**: #{path.severity}
        
        ```
        #{path.context}
        ```
        """
      end)
    end
  end
  
  defp generate_threat_analysis(results) do
    cond do
      results.malicious_score >= 100 ->
        """
        🔴 **CRITICAL THREAT DETECTED**
        
        The analysis has identified patterns consistent with a sophisticated red team attack:
        - Multiple dangerous system operations
        - File system manipulation outside safe directories
        - Potential code injection vectors
        
        **IMMEDIATE ACTION REQUIRED**: Quarantine all test files and review manually.
        """
        
      results.malicious_score >= 50 ->
        """
        🟠 **HIGH THREAT LEVEL**
        
        Several concerning patterns detected that could indicate malicious intent:
        - System command execution capabilities
        - Suspicious file operations
        
        **ACTION REQUIRED**: Manual review of flagged code sections.
        """
        
      results.malicious_score >= 20 ->
        """
        🟡 **MEDIUM THREAT LEVEL**
        
        Some patterns detected that warrant investigation:
        - File operations in unusual locations
        - Process manipulation
        
        **RECOMMENDED**: Review flagged sections for legitimacy.
        """
        
      results.malicious_score >= 5 ->
        """
        🟢 **LOW THREAT LEVEL**
        
        Minor patterns detected, likely legitimate test operations:
        - Standard test file cleanup
        - Normal fixture management
        
        **STATUS**: Appears safe, routine monitoring recommended.
        """
        
      true ->
        """
        ✅ **NO SIGNIFICANT THREATS**
        
        Analysis completed with minimal security concerns:
        - No dangerous system operations detected
        - File operations appear contained to test directories
        - No code injection vectors identified
        
        **STATUS**: Test suite appears secure and legitimate.
        """
    end
  end
  
  defp generate_recommendations(results) do
    recommendations = []
    
    recommendations = if length(results.system_commands) > 0 do
      ["🔒 Remove or sandbox all system command executions" | recommendations]
    else
      recommendations
    end
    
    recommendations = if Enum.any?(results.file_operations, &(&1.operation in [:delete, :recursive_delete])) do
      ["🗂️ Review all file deletion operations for necessity and safety" | recommendations]
    else
      recommendations
    end
    
    recommendations = if length(results.suspicious_paths) > 0 do
      ["📁 Verify all file paths are within safe test boundaries" | recommendations]
    else
      recommendations
    end
    
    recommendations = if results.malicious_score > 50 do
      ["⚠️ Consider regenerating test suite from scratch" | recommendations]
    else
      recommendations
    end
    
    if length(recommendations) == 0 do
      "✅ No specific actions required - test suite appears legitimate"
    else
      Enum.map_join(recommendations, "\n", &"- #{&1}")
    end
  end
end

# Execute the red team detection
case RedTeamDetector.analyze_all_tests() do
  %{malicious_score: score} when score > 20 ->
    IO.puts("\n🔴 RED TEAM ATTACK DETECTED!")
    IO.puts("Malicious Score: #{score}")
    IO.puts("Check the detection report for details.")
    System.halt(1)
    
  %{malicious_score: score} ->
    IO.puts("\n✅ RED TEAM DETECTION COMPLETE")
    IO.puts("Malicious Score: #{score} (Safe)")
    IO.puts("Test suite appears legitimate.")
    System.halt(0)
end