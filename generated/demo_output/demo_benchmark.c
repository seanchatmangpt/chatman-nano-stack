/**
 * BitActor Stress Test & Benchmark - Generated from bitactor_semantic_core
 * Ultra-high performance stress testing
 * Generated by CNS Jinja AOT Compiler
 */

#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>
#include <signal.h>

#define DEMO_IMPLEMENTATION
#include "demo_bitactor.h"

/* Global state */
static volatile int g_running = 1;
static volatile uint64_t g_total_signals = 0;
static volatile uint64_t g_total_ticks = 0;

/* Thread data */
typedef struct {
    int thread_id;
    demo_bitactor_t* ba;
    uint64_t signals_sent;
    uint64_t signals_processed;
    uint64_t ticks;
} thread_data_t;

/* Signal handler for clean shutdown */
static void sigint_handler(int sig) {
    (void)sig;
    printf("\nShutting down...\n");
    g_running = 0;
}

/* Producer thread - generates signals */
static void* producer_thread(void* arg) {
    thread_data_t* data = (thread_data_t*)arg;
    demo_bitactor_t* ba = data->ba;
    
    uint64_t count = 0;
    struct timespec ts = {0, 1000}; /* 1us delay */
    
    while (g_running) {
        demo_signal_t sig = {
            .type = (count % 6) + 1,
            .flags = data->thread_id,
            .timestamp = rdtsc(),
            .payload = count
        };
        
        if (demo_bitactor_enqueue_signal(ba, &sig)) {
            count++;
        } else {
            /* Ring full, back off */
            nanosleep(&ts, NULL);
        }
    }
    
    data->signals_sent = count;
    return NULL;
}

/* Consumer thread - processes signals */
static void* consumer_thread(void* arg) {
    thread_data_t* data = (thread_data_t*)arg;
    demo_bitactor_t* ba = data->ba;
    
    uint64_t processed = 0;
    uint64_t total_ticks = 0;
    
    while (g_running || ba->signal_head != ba->signal_tail) {
        uint64_t start = rdtsc();
        demo_bitactor_tick(ba);
        uint64_t elapsed = rdtsc() - start;
        
        if (ba->signal_count > processed) {
            processed = ba->signal_count;
            total_ticks += elapsed;
        }
    }
    
    data->signals_processed = processed;
    data->ticks = total_ticks;
    return NULL;
}

/* Multi-threaded stress test */
static void stress_test(int num_producers, int num_consumers, int duration_sec) {
    printf("=== Multi-threaded Stress Test ===\n");
    printf("Producers: %d, Consumers: %d, Duration: %ds\n\n", 
           num_producers, num_consumers, duration_sec);
    
    demo_bitactor_t ba;
    demo_bitactor_init(&ba);
    
    pthread_t* producers = malloc(num_producers * sizeof(pthread_t));
    pthread_t* consumers = malloc(num_consumers * sizeof(pthread_t));
    thread_data_t* prod_data = calloc(num_producers, sizeof(thread_data_t));
    thread_data_t* cons_data = calloc(num_consumers, sizeof(thread_data_t));
    
    /* Start producers */
    for (int i = 0; i < num_producers; i++) {
        prod_data[i].thread_id = i;
        prod_data[i].ba = &ba;
        pthread_create(&producers[i], NULL, producer_thread, &prod_data[i]);
    }
    
    /* Start consumers */
    for (int i = 0; i < num_consumers; i++) {
        cons_data[i].thread_id = i;
        cons_data[i].ba = &ba;
        pthread_create(&consumers[i], NULL, consumer_thread, &cons_data[i]);
    }
    
    /* Run for specified duration */
    sleep(duration_sec);
    g_running = 0;
    
    /* Wait for threads */
    for (int i = 0; i < num_producers; i++) {
        pthread_join(producers[i], NULL);
        g_total_signals += prod_data[i].signals_sent;
    }
    
    for (int i = 0; i < num_consumers; i++) {
        pthread_join(consumers[i], NULL);
        g_total_ticks += cons_data[i].ticks;
    }
    
    /* Print results */
    printf("\nResults:\n");
    printf("Total signals sent: %llu\n", (unsigned long long)g_total_signals);
    printf("Total signals processed: %llu\n", (unsigned long long)ba.signal_count);
    printf("Average throughput: %.2f Msignals/sec\n", 
           (double)ba.signal_count / duration_sec / 1e6);
    printf("Average latency: %.2f CPU ticks/signal\n", 
           (double)g_total_ticks / ba.signal_count);
    
    free(producers);
    free(consumers);
    free(prod_data);
    free(cons_data);
}

/* Single-threaded benchmark */
static void benchmark_latency() {
    printf("\n=== Latency Benchmark ===\n");
    
    demo_bitactor_t ba;
    demo_bitactor_init(&ba);
    
    const int WARMUP = 10000;
    const int ITERATIONS = 100000;
    uint64_t* latencies = malloc(ITERATIONS * sizeof(uint64_t));
    
    /* Warmup */
    for (int i = 0; i < WARMUP; i++) {
        demo_signal_t sig = {
            .type = (i % 6) + 1,
            .flags = 0,
            .timestamp = 0,
            .payload = i
        };
        demo_bitactor_enqueue_signal(&ba, &sig);
        demo_bitactor_tick(&ba);
    }
    
    /* Measure latencies */
    for (int i = 0; i < ITERATIONS; i++) {
        demo_signal_t sig = {
            .type = (i % 6) + 1,
            .flags = 0,
            .timestamp = rdtsc(),
            .payload = i
        };
        
        demo_bitactor_enqueue_signal(&ba, &sig);
        
        uint64_t start = rdtsc();
        demo_bitactor_tick(&ba);
        latencies[i] = rdtsc() - start;
    }
    
    /* Calculate statistics */
    uint64_t min = latencies[0], max = latencies[0], sum = 0;
    for (int i = 0; i < ITERATIONS; i++) {
        if (latencies[i] < min) min = latencies[i];
        if (latencies[i] > max) max = latencies[i];
        sum += latencies[i];
    }
    
    /* Sort for percentiles */
    for (int i = 0; i < ITERATIONS - 1; i++) {
        for (int j = i + 1; j < ITERATIONS; j++) {
            if (latencies[i] > latencies[j]) {
                uint64_t temp = latencies[i];
                latencies[i] = latencies[j];
                latencies[j] = temp;
            }
        }
    }
    
    printf("Latency statistics (CPU ticks):\n");
    printf("  Min: %llu\n", (unsigned long long)min);
    printf("  Max: %llu\n", (unsigned long long)max);
    printf("  Avg: %.2f\n", (double)sum / ITERATIONS);
    printf("  P50: %llu\n", (unsigned long long)latencies[ITERATIONS / 2]);
    printf("  P90: %llu\n", (unsigned long long)latencies[ITERATIONS * 9 / 10]);
    printf("  P99: %llu\n", (unsigned long long)latencies[ITERATIONS * 99 / 100]);
    printf("  P99.9: %llu\n", (unsigned long long)latencies[ITERATIONS * 999 / 1000]);
    
    free(latencies);
}

int main(int argc, char** argv) {
    printf("DEMO BitActor Stress Test & Benchmark\n");
    printf("==========================================\n\n");
    
    /* Setup signal handler */
    signal(SIGINT, sigint_handler);
    
    /* Default parameters */
    int producers = 4;
    int consumers = 2;
    int duration = 10;
    
    /* Parse arguments */
    if (argc > 1) producers = atoi(argv[1]);
    if (argc > 2) consumers = atoi(argv[2]);
    if (argc > 3) duration = atoi(argv[3]);
    
    /* Run benchmarks */
    benchmark_latency();
    stress_test(producers, consumers, duration);
    
    printf("\nâœ… Benchmark complete!\n");
    return 0;
}