/**
 * BitActor Unit Tests - Generated from bitactor_semantic_core
 * Test 8-tick performance guarantee and signal processing
 * Generated by CNS Jinja AOT Compiler
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>
#include <string.h>

#define SEMANTIC_IMPLEMENTATION
#include "semantic_bitactor.h"

/* Test utilities */
static uint64_t get_timestamp_ns() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1000000000ULL + ts.tv_nsec;
}

/* Test cases */
static void test_semantic_init() {
    printf("Testing semantic_bitactor_init...\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    assert(ba.signal_head == 0);
    assert(ba.signal_tail == 0);
    assert(ba.tick_count == 0);
    assert(ba.signal_count == 0);
    
    assert(ba.dispatch[SEMANTIC_SIGNAL_SEMANTICSIGNAL] == semantic_handle_semanticsignal_handler);
    assert(ba.dispatch[SEMANTIC_SIGNAL_N0D5A20CF67FD4A7985CB5E643D120CDCB6] == semantic_handle_n0d5a20cf67fd4a7985cb5e643d120cdcb6_handler);
    assert(ba.dispatch[SEMANTIC_SIGNAL_N0D5A20CF67FD4A7985CB5E643D120CDCB7] == semantic_handle_n0d5a20cf67fd4a7985cb5e643d120cdcb7_handler);
    assert(ba.dispatch[SEMANTIC_SIGNAL_HEARTBEATSIGNAL] == semantic_handle_heartbeatsignal_handler);
    assert(ba.dispatch[SEMANTIC_SIGNAL_NORMALSIGNAL] == semantic_handle_normalsignal_handler);
    assert(ba.dispatch[SEMANTIC_SIGNAL_DEBUGSIGNAL] == semantic_handle_debugsignal_handler);
    
    printf("✅ semantic_bitactor_init passed\n");
}

static void test_signal_enqueue() {
    printf("Testing signal enqueue...\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    semantic_signal_t sig = {
        .type = SEMANTIC_SIGNAL_SEMANTICSIGNAL,
        .flags = 0,
        .timestamp = get_timestamp_ns(),
        .payload = 0xDEADBEEF
    };
    
    bool result = semantic_bitactor_enqueue_signal(&ba, &sig);
    assert(result == true);
    assert(ba.signal_head == 1);
    
    printf("✅ Signal enqueue passed\n");
}

static void test_tick_performance() {
    printf("Testing tick performance (8-tick budget)...\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    /* Enqueue test signals */
    semantic_signal_t sig1 = {
        .type = SEMANTIC_SIGNAL_SEMANTICSIGNAL,
        .flags = 0,
        .timestamp = get_timestamp_ns(),
        .payload = 1
    };
    semantic_bitactor_enqueue_signal(&ba, &sig1);
    semantic_signal_t sig2 = {
        .type = SEMANTIC_SIGNAL_N0D5A20CF67FD4A7985CB5E643D120CDCB6,
        .flags = 0,
        .timestamp = get_timestamp_ns(),
        .payload = 2
    };
    semantic_bitactor_enqueue_signal(&ba, &sig2);
    semantic_signal_t sig3 = {
        .type = SEMANTIC_SIGNAL_N0D5A20CF67FD4A7985CB5E643D120CDCB7,
        .flags = 0,
        .timestamp = get_timestamp_ns(),
        .payload = 3
    };
    semantic_bitactor_enqueue_signal(&ba, &sig3);
    
    /* Process signals and measure performance */
    uint64_t total_ticks = 0;
    int processed = 0;
    
    while (ba.signal_head != ba.signal_tail) {
        uint64_t start = rdtsc();
        semantic_bitactor_tick(&ba);
        uint64_t elapsed = rdtsc() - start;
        
        total_ticks += elapsed;
        processed++;
        
        /* Verify tick budget */
        assert(elapsed <= SEMANTIC_TICK_BUDGET);
    }
    
    printf("✅ Processed %d signals, avg ticks: %llu\n", processed, (unsigned long long)(total_ticks / processed));
}

static void test_ring_buffer_overflow() {
    printf("Testing ring buffer overflow protection...\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    semantic_signal_t sig = {
        .type = SEMANTIC_SIGNAL_SEMANTICSIGNAL,
        .flags = 0,
        .timestamp = 0,
        .payload = 0
    };
    
    /* Fill the ring buffer */
    int enqueued = 0;
    while (semantic_bitactor_enqueue_signal(&ba, &sig)) {
        enqueued++;
        if (enqueued > SEMANTIC_RING_SIZE) {
            break; /* Safety check */
        }
    }
    
    assert(enqueued == SEMANTIC_RING_SIZE - 1);
    
    /* Verify overflow protection */
    bool result = semantic_bitactor_enqueue_signal(&ba, &sig);
    assert(result == false);
    
    printf("✅ Ring buffer overflow protection working (capacity: %d)\n", enqueued);
}

static void test_semanticsignal_signal() {
    printf("Testing Semantic Signal signal...\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    semantic_signal_t sig = {
        .type = SEMANTIC_SIGNAL_SEMANTICSIGNAL,
        .flags = 0x1234,
        .timestamp = get_timestamp_ns(),
        .payload = 0xCAFEBABE
    };
    
    semantic_bitactor_enqueue_signal(&ba, &sig);
    semantic_bitactor_tick(&ba);
    
    assert(ba.signal_count == 1);
    printf("✅ Semantic Signal signal processed\n");
}
static void test_n0d5a20cf67fd4a7985cb5e643d120cdcb6_signal() {
    printf("Testing n0d5a20cf67fd4a7985cb5e643d120cdcb6 signal...\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    semantic_signal_t sig = {
        .type = SEMANTIC_SIGNAL_N0D5A20CF67FD4A7985CB5E643D120CDCB6,
        .flags = 0x1234,
        .timestamp = get_timestamp_ns(),
        .payload = 0xCAFEBABE
    };
    
    semantic_bitactor_enqueue_signal(&ba, &sig);
    semantic_bitactor_tick(&ba);
    
    assert(ba.signal_count == 1);
    printf("✅ n0d5a20cf67fd4a7985cb5e643d120cdcb6 signal processed\n");
}
static void test_n0d5a20cf67fd4a7985cb5e643d120cdcb7_signal() {
    printf("Testing n0d5a20cf67fd4a7985cb5e643d120cdcb7 signal...\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    semantic_signal_t sig = {
        .type = SEMANTIC_SIGNAL_N0D5A20CF67FD4A7985CB5E643D120CDCB7,
        .flags = 0x1234,
        .timestamp = get_timestamp_ns(),
        .payload = 0xCAFEBABE
    };
    
    semantic_bitactor_enqueue_signal(&ba, &sig);
    semantic_bitactor_tick(&ba);
    
    assert(ba.signal_count == 1);
    printf("✅ n0d5a20cf67fd4a7985cb5e643d120cdcb7 signal processed\n");
}
static void test_heartbeatsignal_signal() {
    printf("Testing HeartbeatSignal signal...\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    semantic_signal_t sig = {
        .type = SEMANTIC_SIGNAL_HEARTBEATSIGNAL,
        .flags = 0x1234,
        .timestamp = get_timestamp_ns(),
        .payload = 0xCAFEBABE
    };
    
    semantic_bitactor_enqueue_signal(&ba, &sig);
    semantic_bitactor_tick(&ba);
    
    assert(ba.signal_count == 1);
    printf("✅ HeartbeatSignal signal processed\n");
}
static void test_normalsignal_signal() {
    printf("Testing NormalSignal signal...\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    semantic_signal_t sig = {
        .type = SEMANTIC_SIGNAL_NORMALSIGNAL,
        .flags = 0x1234,
        .timestamp = get_timestamp_ns(),
        .payload = 0xCAFEBABE
    };
    
    semantic_bitactor_enqueue_signal(&ba, &sig);
    semantic_bitactor_tick(&ba);
    
    assert(ba.signal_count == 1);
    printf("✅ NormalSignal signal processed\n");
}
static void test_debugsignal_signal() {
    printf("Testing DebugSignal signal...\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    semantic_signal_t sig = {
        .type = SEMANTIC_SIGNAL_DEBUGSIGNAL,
        .flags = 0x1234,
        .timestamp = get_timestamp_ns(),
        .payload = 0xCAFEBABE
    };
    
    semantic_bitactor_enqueue_signal(&ba, &sig);
    semantic_bitactor_tick(&ba);
    
    assert(ba.signal_count == 1);
    printf("✅ DebugSignal signal processed\n");
}

/* Benchmark suite */
static void benchmark_throughput() {
    printf("\n=== Throughput Benchmark ===\n");
    
    semantic_bitactor_t ba;
    semantic_bitactor_init(&ba);
    
    const int NUM_SIGNALS = 1000000;
    uint64_t start_time = get_timestamp_ns();
    
    for (int i = 0; i < NUM_SIGNALS; i++) {
        semantic_signal_t sig = {
            .type = (i % 6) + 1,
            .flags = 0,
            .timestamp = i,
            .payload = i
        };
        
        while (!semantic_bitactor_enqueue_signal(&ba, &sig)) {
            semantic_bitactor_tick(&ba);
        }
        
        if (ba.signal_head == ba.signal_tail + 1) {
            semantic_bitactor_tick(&ba);
        }
    }
    
    /* Process remaining signals */
    while (ba.signal_head != ba.signal_tail) {
        semantic_bitactor_tick(&ba);
    }
    
    uint64_t elapsed_ns = get_timestamp_ns() - start_time;
    double throughput = (double)NUM_SIGNALS / (elapsed_ns / 1e9);
    
    printf("Processed %d signals in %.3f ms\n", NUM_SIGNALS, elapsed_ns / 1e6);
    printf("Throughput: %.2f signals/sec (%.2f MHz)\n", throughput, throughput / 1e6);
    printf("Average latency: %.2f ns/signal\n", (double)elapsed_ns / NUM_SIGNALS);
}

int main(int argc, char** argv) {
    printf("SEMANTIC BitActor Test Suite\n");
    printf("================================\n\n");
    
    /* Run unit tests */
    test_semantic_init();
    test_signal_enqueue();
    test_tick_performance();
    test_ring_buffer_overflow();
    
    test_semanticsignal_signal();
    test_n0d5a20cf67fd4a7985cb5e643d120cdcb6_signal();
    test_n0d5a20cf67fd4a7985cb5e643d120cdcb7_signal();
    test_heartbeatsignal_signal();
    test_normalsignal_signal();
    test_debugsignal_signal();
    
    /* Run benchmarks */
    if (argc > 1 && strcmp(argv[1], "--bench") == 0) {
        benchmark_throughput();
    }
    
    printf("\n✅ All tests passed!\n");
    return 0;
}