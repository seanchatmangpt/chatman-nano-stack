defmodule CnsForge.Generators.Templates.ResourceTemplate do
  @moduledoc """
  ðŸ”„ RECURSIVE RESOURCE TEMPLATE: Generates Ash.Resource generators
  
  This template can generate generators that generate Ash resources with
  infinite recursion capabilities. It supports:
  
  - Self-referential resource definitions
  - Recursive relationship patterns  
  - Fractal attribute structures
  - Infinite depth generation
  - Meta-resource generation (resources that define other resources)
  """
  
  @behaviour CnsForge.Generators.Templates.GeneratorTemplate
  
  @impl true
  def base_template do
    """
    defmodule {{MODULE_NAME}} do
      @moduledoc \"\"\"
      ðŸ”„ RECURSIVE ASH RESOURCE GENERATOR
      
      Generated by: CnsForge.Generators.Templates.ResourceTemplate
      
      This generator creates Ash.Resource modules with recursive capabilities:
      - {{CAPABILITIES}}
      - Recursive depth: {{RECURSIVE_DEPTH}}
      - Self-referential: {{SELF_REFERENTIAL}}
      
      ## Usage
      
          {{MODULE_NAME}}.generate_resource(:{{RESOURCE_NAME}}, %{
            domain: {{DOMAIN_NAME}},
            attributes: {{ATTRIBUTES}},
            relationships: {{RELATIONSHIPS}},
            actions: {{ACTIONS}},
            recursive_patterns: {{RECURSIVE_PATTERNS}}
          })
      \"\"\"
      
      use GenServer
      require Logger
      
      alias CnsForge.Generators.Templates.ResourceTemplate
      alias CnsForge.Generators.Patterns.RecursivePattern
      
      # Configuration
      @recursive_depth {{RECURSIVE_DEPTH}}
      @self_referential {{SELF_REFERENTIAL}}
      @fractal_enabled {{FRACTAL_ENABLED}}
      
      ## Public API
      
      @doc \"\"\"
      Generate an Ash.Resource with recursive capabilities
      \"\"\"
      def generate_resource(resource_name, spec) do
        GenServer.call(__MODULE__, {:generate_resource, resource_name, spec})
      end
      
      @doc \"\"\"
      Generate a resource that can generate other resources (meta-resource)
      \"\"\"
      def generate_meta_resource(meta_name, meta_spec) do
        GenServer.call(__MODULE__, {:generate_meta_resource, meta_name, meta_spec})
      end
      
      @doc \"\"\"
      Generate resources recursively based on patterns
      \"\"\"
      def generate_recursive_resources(base_spec, patterns) do
        GenServer.call(__MODULE__, {:generate_recursive_resources, base_spec, patterns})
      end
      
      @doc \"\"\"
      Generate infinite variations of a resource
      \"\"\"
      def generate_infinite_variations(base_spec) do
        Stream.iterate(base_spec, &evolve_resource_spec/1)
        |> Stream.map(&generate_resource_from_spec/1)
        |> Stream.take_while(&should_continue_generation?/1)
      end
      
      ## GenServer Implementation
      
      def start_link(opts \\ []) do
        GenServer.start_link(__MODULE__, opts, name: __MODULE__)
      end
      
      @impl GenServer
      def init(opts) do
        state = %{
          generation_cache: %{},
          recursive_depth: Keyword.get(opts, :recursive_depth, @recursive_depth),
          pattern_library: initialize_pattern_library(),
          resource_registry: %{}
        }
        {:ok, state}
      end
      
      @impl GenServer
      def handle_call({:generate_resource, resource_name, spec}, _from, state) do
        case generate_resource_impl(resource_name, spec, state) do
          {:ok, file_path, new_state} ->
            {:reply, {:ok, file_path}, new_state}
          {:error, reason} ->
            {:reply, {:error, reason}, state}
        end
      end
      
      @impl GenServer
      def handle_call({:generate_meta_resource, meta_name, meta_spec}, _from, state) do
        case generate_meta_resource_impl(meta_name, meta_spec, state) do
          {:ok, file_path, new_state} ->
            {:reply, {:ok, file_path}, new_state}
          {:error, reason} ->
            {:reply, {:error, reason}, state}
        end
      end
      
      @impl GenServer
      def handle_call({:generate_recursive_resources, base_spec, patterns}, _from, state) do
        case generate_recursive_resources_impl(base_spec, patterns, state) do
          {:ok, file_paths, new_state} ->
            {:reply, {:ok, file_paths}, new_state}
          {:error, reason} ->
            {:reply, {:error, reason}, state}
        end
      end
      
      ## Implementation Functions
      
      defp generate_resource_impl(resource_name, spec, state) do
        resource_code = build_resource_code(resource_name, spec)
        
        # Apply recursive patterns if specified
        enhanced_code = 
          if spec[:recursive_patterns] do
            apply_recursive_patterns(resource_code, spec[:recursive_patterns], state)
          else
            resource_code
          end
        
        # Add self-referential capabilities if enabled
        final_code = 
          if @self_referential and spec[:self_referential] do
            add_self_referential_capabilities(enhanced_code, resource_name, spec)
          else
            enhanced_code
          end
        
        # Write to file system
        file_path = resource_file_path(resource_name)
        File.mkdir_p!(Path.dirname(file_path))
        File.write!(file_path, final_code)
        
        # Update state
        new_state = register_resource(state, resource_name, spec, file_path)
        
        Logger.info("âœ… Generated recursive resource: #{file_path}")
        {:ok, file_path, new_state}
      end
      
      defp generate_meta_resource_impl(meta_name, meta_spec, state) do
        meta_resource_code = build_meta_resource_code(meta_name, meta_spec)
        
        file_path = resource_file_path(meta_name)
        File.mkdir_p!(Path.dirname(file_path))
        File.write!(file_path, meta_resource_code)
        
        new_state = register_resource(state, meta_name, meta_spec, file_path)
        {:ok, file_path, new_state}
      end
      
      defp generate_recursive_resources_impl(base_spec, patterns, state) do
        generated_paths = 
          patterns
          |> Enum.with_index()
          |> Enum.map(fn {pattern, index} ->
            resource_name = :"#{base_spec.name}_recursive_#{index}"
            recursive_spec = apply_pattern_to_spec(base_spec, pattern)
            
            case generate_resource_impl(resource_name, recursive_spec, state) do
              {:ok, path, _new_state} -> path
              {:error, _reason} -> nil
            end
          end)
          |> Enum.filter(& &1)
        
        {:ok, generated_paths, state}
      end
      
      ## Resource Code Generation
      
      defp build_resource_code(resource_name, spec) do
        module_name = build_module_name(resource_name, spec)
        domain_name = spec[:domain] || default_domain_name(resource_name)
        
        \"\"\"
        defmodule #{module_name} do
          @moduledoc \"\"\"
          ðŸ”„ RECURSIVE ASH RESOURCE: #{resource_name}
          
          #{spec[:description] || "Auto-generated Ash resource with recursive capabilities"}
          
          Generated by: {{MODULE_NAME}}
          Recursive Patterns: #{inspect(spec[:recursive_patterns] || [])}
          Self-Referential: #{spec[:self_referential] || @self_referential}
          \"\"\"
          
          use Ash.Resource,
            otp_app: :cns_forge,
            domain: #{inspect(domain_name)}
          
          #{generate_attributes_section(spec[:attributes] || [])}
          
          #{generate_relationships_section(spec[:relationships] || [])}
          
          #{generate_actions_section(spec[:actions] || [])}
          
          #{generate_calculations_section(spec[:calculations] || [])}
          
          #{generate_aggregates_section(spec[:aggregates] || [])}
          
          #{if spec[:recursive_patterns], do: generate_recursive_methods(spec[:recursive_patterns]), else: ""}
          
          #{if @fractal_enabled and spec[:fractal], do: generate_fractal_methods(spec[:fractal]), else: ""}
          
          # Recursive resource generation capabilities
          #{generate_resource_generation_methods(resource_name, spec)}
        end
        \"\"\"
      end
      
      defp build_meta_resource_code(meta_name, meta_spec) do
        module_name = build_module_name(meta_name, meta_spec)
        
        \"\"\"
        defmodule #{module_name} do
          @moduledoc \"\"\"
          ðŸ”„ META-RESOURCE: #{meta_name}
          
          This resource can generate other resources based on specifications.
          
          Target Resources: #{inspect(meta_spec[:target_resources] || [])}
          Generation Patterns: #{inspect(meta_spec[:generation_patterns] || [])}
          \"\"\"
          
          use Ash.Resource,
            otp_app: :cns_forge,
            domain: #{inspect(meta_spec[:domain] || CnsForge.MetaDomain)}
          
          attributes do
            uuid_v7_primary_key :id
            attribute :name, :string, public?: true, allow_nil?: false
            attribute :resource_spec, :map, public?: true
            attribute :generation_patterns, {:array, :atom}, public?: true, default: []
            attribute :recursive_depth, :integer, public?: true, default: 0
            attribute :generated_resources, {:array, :string}, public?: true, default: []
            timestamps()
          end
          
          actions do
            defaults [:read, :create, :update, :destroy]
            
            create :generate_resource do
              accept [:name, :resource_spec, :generation_patterns, :recursive_depth]
              change after_action(&generate_target_resource/2)
            end
            
            update :generate_recursive do
              accept [:recursive_depth, :generation_patterns]
              change after_action(&generate_recursive_resources/2)
            end
          end
          
          # Meta-resource generation methods
          #{generate_meta_resource_methods(meta_spec)}
        end
        \"\"\"
      end
      
      ## Code Section Generators
      
      defp generate_attributes_section(attributes) do
        if Enum.empty?(attributes) do
          \"\"\"
          attributes do
            uuid_v7_primary_key :id
            timestamps()
          end
          \"\"\"
        else
          attribute_code = 
            attributes
            |> Enum.map(&format_attribute/1)
            |> Enum.join("\\n    ")
          
          \"\"\"
          attributes do
            uuid_v7_primary_key :id
            #{attribute_code}
            timestamps()
          end
          \"\"\"
        end
      end
      
      defp generate_relationships_section(relationships) do
        if Enum.empty?(relationships) do
          ""
        else
          relationship_code = 
            relationships
            |> Enum.map(&format_relationship/1)
            |> Enum.join("\\n    ")
          
          \"\"\"
          relationships do
            #{relationship_code}
          end
          \"\"\"
        end
      end
      
      defp generate_actions_section(actions) do
        default_actions = actions[:defaults] || [:read, :create, :update, :destroy]
        custom_actions = actions[:custom] || []
        
        action_code = 
          if Enum.empty?(custom_actions) do
            "defaults #{inspect(default_actions)}"
          else
            custom_action_code = 
              custom_actions
              |> Enum.map(&format_action/1)
              |> Enum.join("\\n\\n    ")
            
            \"\"\"
            defaults #{inspect(default_actions)}
            
            #{custom_action_code}
            \"\"\"
          end
        
        \"\"\"
        actions do
          #{action_code}
        end
        \"\"\"
      end
      
      defp generate_calculations_section(calculations) do
        if Enum.empty?(calculations) do
          ""
        else
          calculation_code = 
            calculations
            |> Enum.map(&format_calculation/1)
            |> Enum.join("\\n\\n    ")
          
          \"\"\"
          calculations do
            #{calculation_code}
          end
          \"\"\"
        end
      end
      
      defp generate_aggregates_section(aggregates) do
        if Enum.empty?(aggregates) do
          ""
        else
          aggregate_code = 
            aggregates
            |> Enum.map(&format_aggregate/1)
            |> Enum.join("\\n\\n    ")
          
          \"\"\"
          aggregates do
            #{aggregate_code}
          end
          \"\"\"
        end
      end
      
      ## Recursive Method Generators
      
      defp generate_recursive_methods(patterns) do
        pattern_methods = 
          patterns
          |> Enum.map(&generate_pattern_method/1)
          |> Enum.join("\\n\\n  ")
        
        \"\"\"
        
        # ðŸ”„ RECURSIVE METHODS
        # Generated methods for recursive patterns: #{inspect(patterns)}
        
        #{pattern_methods}
        
        def apply_recursive_pattern(pattern, data, depth \\ 0) do
          if depth > @recursive_depth do
            data
          else
            case pattern do
              #{generate_pattern_cases(patterns)}
              _ -> data
            end
          end
        end
        \"\"\"
      end
      
      defp generate_fractal_methods(fractal_spec) do
        \"\"\"
        
        # ðŸ”„ FRACTAL METHODS
        # Generated methods for fractal patterns
        
        def generate_fractal_structure(scale_factor \\ 0.5, max_depth \\ 10) do
          build_fractal(self(), scale_factor, 0, max_depth)
        end
        
        defp build_fractal(base, scale, depth, max_depth) when depth < max_depth do
          scaled_attributes = scale_attributes(base.__struct__.__ash_attributes__(), scale)
          nested_structures = 
            base.__struct__.__ash_relationships__()
            |> Enum.map(fn rel -> 
              build_fractal(rel.destination, scale * scale_factor, depth + 1, max_depth)
            end)
          
          combine_fractal_elements(scaled_attributes, nested_structures)
        end
        defp build_fractal(base, _scale, _depth, _max_depth), do: base
        \"\"\"
      end
      
      defp generate_resource_generation_methods(resource_name, spec) do
        \"\"\"
        
        # ðŸ”„ RESOURCE GENERATION METHODS
        # Methods for generating related resources
        
        def generate_related_resource(relation_type, relation_spec) do
          related_name = :"#{resource_name}_#{relation_type}"
          related_spec = build_related_spec(relation_spec, #{inspect(spec)})
          
          case {{MODULE_NAME}}.generate_resource(related_name, related_spec) do
            {:ok, path} -> 
              Logger.info("Generated related resource: \#{path}")
              {:ok, path}
            error -> error
          end
        end
        
        def generate_variant(variant_name, modifications) do
          variant_spec = apply_modifications(#{inspect(spec)}, modifications)
          {{MODULE_NAME}}.generate_resource(variant_name, variant_spec)
        end
        
        def replicate_with_pattern(pattern, count \\ 5) do
          1..count
          |> Enum.map(fn i ->
            replica_name = :"#{resource_name}_replica_\#{i}"
            replica_spec = apply_pattern_to_spec(#{inspect(spec)}, pattern)
            {{MODULE_NAME}}.generate_resource(replica_name, replica_spec)
          end)
          |> Enum.filter(fn {:ok, _} -> true; _ -> false end)
          |> Enum.map(fn {:ok, path} -> path end)
        end
        \"\"\"
      end
      
      defp generate_meta_resource_methods(meta_spec) do
        target_resources = meta_spec[:target_resources] || []
        
        resource_generation_methods = 
          target_resources
          |> Enum.map(fn resource_type ->
            \"\"\"
            def generate_#{resource_type}(spec) do
              resource_name = spec[:name] || generate_unique_name(:#{resource_type})
              enhanced_spec = enhance_spec_for_#{resource_type}(spec)
              
              case {{MODULE_NAME}}.generate_resource(resource_name, enhanced_spec) do
                {:ok, path} ->
                  update_generated_resources_list(path)
                  {:ok, path}
                error -> error
              end
            end
            
            defp enhance_spec_for_#{resource_type}(spec) do
              spec
              |> Map.put(:type, :#{resource_type})
              |> Map.put_new(:recursive_patterns, [:#{resource_type}_pattern])
            end
            \"\"\"
          end)
          |> Enum.join("\\n\\n  ")
        
        \"\"\"
        
        # Meta-resource generation methods
        #{resource_generation_methods}
        
        defp generate_target_resource(changeset, meta_resource) do
          spec = Ash.Changeset.get_attribute(changeset, :resource_spec)
          patterns = Ash.Changeset.get_attribute(changeset, :generation_patterns)
          
          case generate_from_spec(spec, patterns) do
            {:ok, path} ->
              updated_resources = [path | meta_resource.generated_resources]
              {:ok, Ash.Changeset.change_attribute(changeset, :generated_resources, updated_resources)}
            {:error, reason} ->
              {:error, "Failed to generate resource: \#{inspect(reason)}"}
          end
        end
        
        defp generate_recursive_resources(changeset, meta_resource) do
          depth = Ash.Changeset.get_attribute(changeset, :recursive_depth)
          patterns = Ash.Changeset.get_attribute(changeset, :generation_patterns)
          
          case generate_recursive_variations(meta_resource.resource_spec, patterns, depth) do
            {:ok, paths} ->
              updated_resources = paths ++ meta_resource.generated_resources
              {:ok, Ash.Changeset.change_attribute(changeset, :generated_resources, updated_resources)}
            {:error, reason} ->
              {:error, "Failed to generate recursive resources: \#{inspect(reason)}"}
          end
        end
        \"\"\"
      end
      
      ## Helper Functions
      
      defp format_attribute(attr) do
        case attr do
          {name, type} ->
            "attribute :#{name}, #{inspect(type)}, public?: true"
          {name, type, opts} ->
            opts_str = format_attribute_options(opts)
            "attribute :#{name}, #{inspect(type)}#{opts_str}"
          attr_map when is_map(attr_map) ->
            name = attr_map.name
            type = attr_map.type
            opts = Map.drop(attr_map, [:name, :type])
            opts_str = format_attribute_options(opts)
            "attribute :#{name}, #{inspect(type)}#{opts_str}"
        end
      end
      
      defp format_relationship(rel) do
        case rel do
          {type, name, destination} ->
            "#{type} :#{name}, #{destination}"
          {type, name, destination, opts} ->
            opts_str = format_relationship_options(opts)
            "#{type} :#{name}, #{destination}#{opts_str}"
          rel_map when is_map(rel_map) ->
            type = rel_map.type
            name = rel_map.name
            dest = rel_map.destination
            opts = Map.drop(rel_map, [:type, :name, :destination])
            opts_str = format_relationship_options(opts)
            "#{type} :#{name}, #{dest}#{opts_str}"
        end
      end
      
      defp format_action(action) do
        case action do
          {name, type} ->
            "#{type} :#{name}"
          {name, type, opts} ->
            opts_str = format_action_options(opts)
            "#{type} :#{name}#{opts_str}"
          action_map when is_map(action_map) ->
            name = action_map.name
            type = action_map.type
            opts = Map.drop(action_map, [:name, :type])
            opts_str = format_action_options(opts)
            "#{type} :#{name}#{opts_str}"
        end
      end
      
      defp format_calculation(calc) do
        case calc do
          {name, expr} ->
            "calculate :#{name}, :string, expr(#{expr})"
          calc_map when is_map(calc_map) ->
            name = calc_map.name
            type = calc_map.type || :string
            expr = calc_map.expression
            "calculate :#{name}, #{inspect(type)}, expr(#{expr})"
        end
      end
      
      defp format_aggregate(agg) do
        case agg do
          {name, kind, relationship} ->
            "#{kind} :#{name}, :#{relationship}"
          agg_map when is_map(agg_map) ->
            name = agg_map.name
            kind = agg_map.kind
            rel = agg_map.relationship
            field = agg_map[:field]
            if field do
              "#{kind} :#{name}, :#{rel}, :#{field}"
            else
              "#{kind} :#{name}, :#{rel}"
            end
        end
      end
      
      # Additional helper functions...
      #{generate_additional_helpers()}
    end
    """
  end
  
  @impl true
  def template_variables do
    [
      :module_name, :resource_name, :domain_name, :capabilities,
      :recursive_depth, :self_referential, :fractal_enabled,
      :attributes, :relationships, :actions, :recursive_patterns
    ]
  end
  
  @impl true
  def recursive_patterns do
    [:fractal, :self_referential, :infinite_depth, :pattern_replication]
  end
  
  @impl true
  def self_modification_enabled? do
    true
  end
  
  # Private helper functions
  
  defp generate_additional_helpers do
    """
    defp build_module_name(resource_name, spec) do
      namespace = spec[:namespace] || "CnsForge.Resources"
      Module.concat([namespace, Macro.camelize(to_string(resource_name))])
    end
    
    defp default_domain_name(resource_name) do
      "CnsForge.#{Macro.camelize(to_string(resource_name))}Domain"
    end
    
    defp resource_file_path(resource_name) do
      "lib/cns_forge/resources/#{Macro.underscore(to_string(resource_name))}.ex"
    end
    
    defp apply_recursive_patterns(code, patterns, _state) do
      Enum.reduce(patterns, code, fn pattern, acc ->
        case pattern do
          :fractal -> add_fractal_capabilities(acc)
          :infinite_depth -> add_infinite_depth_capabilities(acc)
          :self_referential -> add_self_referential_capabilities(acc)
          _ -> acc
        end
      end)
    end
    
    defp add_self_referential_capabilities(code, resource_name, _spec) do
      self_ref_code = \"\"\"
      
      # ðŸ”„ SELF-REFERENTIAL CAPABILITIES
      # This resource can reference and modify itself
      
      relationships do
        has_many :recursive_references, __MODULE__
        belongs_to :parent_reference, __MODULE__
      end
      
      def create_self_reference(attrs \\ %{}) do
        attrs_with_parent = Map.put(attrs, :parent_reference_id, self().id)
        Ash.create!(__MODULE__, attrs_with_parent)
      end
      
      def replicate_self(modifications \\ %{}) do
        current_attrs = Ash.to_map(self())
        new_attrs = Map.merge(current_attrs, modifications)
        Ash.create!(__MODULE__, new_attrs)
      end
      \"\"\"
      
      code <> self_ref_code
    end
    
    defp register_resource(state, resource_name, spec, file_path) do
      resource_entry = %{
        name: resource_name,
        spec: spec,
        file_path: file_path, 
        created_at: DateTime.utc_now()
      }
      
      %{state | resource_registry: Map.put(state.resource_registry, resource_name, resource_entry)}
    end
    
    defp initialize_pattern_library do
      %{
        fractal: CnsForge.Generators.Patterns.FractalPattern,
        infinite: CnsForge.Generators.Patterns.InfinitePattern,
        self_referential: CnsForge.Generators.Patterns.SelfReferentialPattern
      }
    end
    
    defp generate_pattern_method(pattern) do
      \"\"\"
      def apply_#{pattern}_pattern(data, opts \\ []) do
        pattern_module = @pattern_library[:#{pattern}]
        if pattern_module do
          pattern_module.apply(data, opts)
        else
          Logger.warn("Pattern not found: #{pattern}")
          data
        end
      end
      \"\"\"
    end
    
    defp generate_pattern_cases(patterns) do
      patterns
      |> Enum.map(fn pattern ->
        \":#{pattern} -> apply_#{pattern}_pattern(data, [depth: depth + 1])\"
      end)
      |> Enum.join("\\n              ")
    end
    
    defp format_attribute_options(opts) when is_map(opts) do
      if map_size(opts) == 0 do
        ""
      else
        opts_list = 
          opts
          |> Enum.map(fn {k, v} -> "\#{k}: \#{inspect(v)}" end)
          |> Enum.join(", ")
        ", " <> opts_list
      end
    end
    
    defp format_relationship_options(opts) when is_map(opts) do
      format_attribute_options(opts)
    end
    
    defp format_action_options(opts) when is_map(opts) do
      format_attribute_options(opts)
    end
    """
  end
end