defmodule CnsForge.Generators.Templates.GeneratorTemplate do
  @moduledoc """
  ðŸ”„ RECURSIVE TEMPLATE SYSTEM: Base template for all generator templates
  
  This module provides the foundation for creating recursive, self-modifying
  generator templates. Templates can generate other templates, creating an
  infinite depth of generation capabilities.
  
  ## Template Hierarchy
  
  ```
  GeneratorTemplate (this)
  â”œâ”€â”€ ResourceTemplate
  â”œâ”€â”€ DomainTemplate  
  â”œâ”€â”€ ActionTemplate
  â”œâ”€â”€ WorkflowTemplate
  â””â”€â”€ MetaTemplate (generates other templates)
  ```
  """
  
  @callback base_template() :: String.t()
  @callback template_variables() :: [atom()]
  @callback recursive_patterns() :: [atom()]
  @callback self_modification_enabled?() :: boolean()
  
  @doc """
  Generate a new template that can generate templates
  """
  def generate_meta_template(template_spec) do
    """
    defmodule CnsForge.Generators.Templates.#{template_spec.name} do
      @moduledoc \"\"\"
      ðŸ”„ AUTO-GENERATED TEMPLATE: #{template_spec.description}
      
      Generated by: #{__MODULE__}
      Capabilities: #{inspect(template_spec.capabilities)}
      Recursive Depth: #{template_spec.recursive_depth}
      \"\"\"
      
      @behaviour CnsForge.Generators.Templates.GeneratorTemplate
      
      #{generate_template_implementation(template_spec)}
      
      # Recursive template generation
      def generate_child_template(child_spec) do
        child_template = apply_template_recursion(base_template(), child_spec)
        create_template_module(child_spec.name, child_template)
      end
      
      # Self-modification capabilities
      #{if template_spec.self_modifying, do: generate_self_modification_code(), else: ""}
      
      # Template composition for infinite recursion
      def compose_templates(templates) when is_list(templates) do
        Enum.reduce(templates, base_template(), &merge_templates/2)
      end
      
      defp apply_template_recursion(base, spec) do
        base
        |> apply_recursive_patterns(spec.patterns || [])
        |> apply_template_variables(spec.variables || %{})
        |> enhance_with_capabilities(spec.capabilities || [])
      end
      
      defp create_template_module(name, template_code) do
        module_name = Module.concat([CnsForge.Generators.Templates, name])
        module_code = build_module_code(module_name, template_code)
        
        # Write to file system
        file_path = template_file_path(name)
        File.mkdir_p!(Path.dirname(file_path))
        File.write!(file_path, module_code)
        
        # Compile dynamically
        Code.compile_string(module_code)
        
        {:ok, module_name, file_path}
      end
      
      #{generate_helper_functions(template_spec)}
    end
    """
  end
  
  @doc """
  Base template for standard generators
  """
  def base_generator_template do
    """
    defmodule {{MODULE_NAME}} do
      @moduledoc \"\"\"
      ðŸ”„ GENERATED GENERATOR: {{GENERATOR_DESCRIPTION}}
      
      Generated by: CnsForge.Generators.Meta.RecursiveGenerator
      Template: #{__MODULE__}
      
      ## Capabilities
      {{CAPABILITIES}}
      
      ## Usage
      
          {{MODULE_NAME}}.generate({{GENERATOR_ID}}, %{
            {{EXAMPLE_SPEC}}
          })
      \"\"\"
      
      use GenServer
      require Logger
      
      #{generate_standard_generator_functions()}
      
      # Generator-specific implementation
      {{GENERATOR_IMPLEMENTATION}}
      
      # Recursive generation capabilities
      {{RECURSIVE_CAPABILITIES}}
      
      # Self-improvement methods (if enabled)
      {{SELF_IMPROVEMENT_METHODS}}
      
      # Template application methods
      {{TEMPLATE_METHODS}}
    end
    """
  end
  
  defp generate_template_implementation(template_spec) do
    """
    @impl true
    def base_template do
      \"\"\"
      #{template_spec.base_template || base_generator_template()}
      \"\"\"
    end
    
    @impl true
    def template_variables do
      #{inspect(template_spec.variables || [])}
    end
    
    @impl true
    def recursive_patterns do
      #{inspect(template_spec.recursive_patterns || [])}
    end
    
    @impl true
    def self_modification_enabled? do
      #{template_spec.self_modifying || false}
    end
    """
  end
  
  defp generate_self_modification_code do
    """
    def modify_template(modifications) do
      current_code = File.read!(__ENV__.file)
      new_code = apply_template_modifications(current_code, modifications)
      File.write!(__ENV__.file, new_code)
      Code.compile_file(__ENV__.file)
    end
    
    def evolve_template(usage_patterns) do
      optimizations = analyze_usage_patterns(usage_patterns)
      modify_template(optimizations)
    end
    
    defp apply_template_modifications(code, modifications) do
      Enum.reduce(modifications, code, fn
        {:add_capability, capability_code}, acc ->
          insert_before_end(acc, capability_code)
          
        {:optimize_pattern, old_pattern, new_pattern}, acc ->
          String.replace(acc, old_pattern, new_pattern)
          
        {:add_recursive_depth, depth_config}, acc ->
          add_recursion_config(acc, depth_config)
      end)
    end
    
    defp analyze_usage_patterns(patterns) do
      # Analyze how the template is being used and suggest improvements
      patterns
      |> identify_common_patterns()
      |> generate_optimizations()
    end
    """
  end
  
  defp generate_standard_generator_functions do
    """
    @doc \"\"\"
    Generate code based on the provided specification
    \"\"\"
    def generate(spec, opts \\ []) do
      context = build_generation_context(spec, opts)
      
      with {:ok, template} <- load_template(spec),
           {:ok, code} <- apply_template(template, context),
           {:ok, path} <- write_generated_code(code, context) do
        {:ok, path}
      else
        error -> error
      end
    end
    
    @doc \"\"\"
    Generate recursively with specified depth
    \"\"\"
    def generate_recursive(spec, depth \\ 0, max_depth \\ 10) do
      if depth >= max_depth do
        {:error, :max_recursion_depth}
      else
        case generate(spec) do
          {:ok, result} ->
            if should_recurse?(spec, depth) do
              recursive_spec = build_recursive_spec(spec, result)
              generate_recursive(recursive_spec, depth + 1, max_depth)
            else
              {:ok, result}
            end
          error -> error
        end
      end
    end
    
    @doc \"\"\"
    Generate with infinite recursion capability
    \"\"\"
    def generate_infinite(spec) do
      spec
      |> build_infinite_stream()
      |> Stream.take_while(&continue_generation?/1)
      |> Enum.to_list()
    end
    
    # Generation context and helper functions
    defp build_generation_context(spec, opts) do
      %{
        spec: spec,
        opts: opts,
        timestamp: DateTime.utc_now(),
        generation_id: generate_unique_id(),
        recursive_refs: [],
        depth: 0
      }
    end
    
    defp load_template(spec) do
      template_name = spec[:template] || :default
      case template_registry()[template_name] do
        nil -> {:error, :template_not_found}
        template -> {:ok, template}
      end
    end
    
    defp apply_template(template, context) do
      try do
        result = template
        |> substitute_variables(context)
        |> apply_recursive_patterns(context)
        |> apply_transformations(context)
        
        {:ok, result}
      rescue
        error -> {:error, error}
      end
    end
    
    defp write_generated_code(code, context) do
      file_path = determine_output_path(context)
      File.mkdir_p!(Path.dirname(file_path))
      File.write!(file_path, code)
      {:ok, file_path}
    end
    """
  end
  
  defp generate_helper_functions(template_spec) do
    """
    # Helper functions for template operations
    
    defp substitute_variables(template, context) do
      context.spec
      |> Map.merge(context.opts)
      |> Enum.reduce(template, fn {key, value}, acc ->
        placeholder = "{{#{String.upcase(to_string(key))}}}"
        String.replace(acc, placeholder, to_string(value))
      end)
    end
    
    defp apply_recursive_patterns(template, context) do
      #{inspect(template_spec.recursive_patterns || [])}
      |> Enum.reduce(template, fn pattern, acc ->
        apply_pattern(acc, pattern, context)
      end)
    end
    
    defp apply_pattern(template, pattern, context) do
      case pattern do
        :fractal -> apply_fractal_pattern(template, context)
        :infinite -> apply_infinite_pattern(template, context)
        :self_referential -> apply_self_reference(template, context)
        _ -> template
      end
    end
    
    defp apply_fractal_pattern(template, context) do
      # Generate fractal-like nested structures
      scale_factor = context.opts[:scale_factor] || 0.5
      generate_nested_structure(template, scale_factor, context.depth)
    end
    
    defp apply_infinite_pattern(template, context) do
      # Create infinite generation capability
      stream_template = wrap_in_stream_generator(template)
      add_continuation_logic(stream_template, context)
    end
    
    defp apply_self_reference(template, context) do
      # Add self-referential capabilities
      self_ref_code = generate_self_reference_code(context)
      insert_self_reference(template, self_ref_code)
    end
    
    defp apply_transformations(template, context) do
      #{inspect(template_spec.transformations || [])}
      |> Enum.reduce(template, fn transformation, acc ->
        apply_transformation(acc, transformation, context)
      end)
    end
    
    defp template_registry do
      %{
        default: base_template(),
        recursive: recursive_template(),
        meta: meta_template(),
        infinite: infinite_template()
      }
    end
    
    defp recursive_template do
      \"\"\"
      # Recursive template that generates similar structures
      def generate_recursive_structure(spec, depth \\ 0) do
        if depth > spec.max_depth do
          base_case(spec)
        else
          recursive_case(spec, depth + 1)
        end
      end
      \"\"\"
    end
    
    defp meta_template do
      \"\"\"
      # Meta template that generates other templates
      def generate_template(template_spec) do
        base_structure = build_base_template(template_spec)
        enhanced_structure = add_meta_capabilities(base_structure)
        finalize_template(enhanced_structure, template_spec)
      end
      \"\"\"
    end
    
    defp infinite_template do
      \"\"\"
      # Infinite template that can generate unlimited variations
      def generate_infinite_variations(base_spec) do
        Stream.iterate(base_spec, &evolve_spec/1)
        |> Stream.map(&generate_from_spec/1)
        |> Stream.take_while(&should_continue_generation?/1)
      end
      \"\"\"
    end
    
    defp should_recurse?(spec, depth) do
      case spec[:recursion_strategy] do
        :infinite -> true
        {:max_depth, max} -> depth < max
        :conditional -> evaluate_recursion_condition(spec, depth)
        _ -> false
      end
    end
    
    defp build_recursive_spec(spec, _result) do
      # Build the next iteration specification
      Map.update(spec, :iteration, 0, &(&1 + 1))
    end
    
    defp build_infinite_stream(spec) do
      Stream.iterate(spec, &enhance_spec_for_next_iteration/1)
    end
    
    defp continue_generation?(spec) do
      # Determine if generation should continue
      spec[:continue] != false and 
      spec[:max_iterations] |> is_nil() or spec[:current_iteration] < spec[:max_iterations]
    end
    
    defp generate_unique_id do
      :crypto.strong_rand_bytes(8) |> Base.encode16(case: :lower)
    end
    
    defp determine_output_path(context) do
      base_path = context.opts[:output_path] || "lib/cns_forge/generated"
      filename = "#{context.spec[:name] || "generated"}_#{context.generation_id}.ex"
      Path.join(base_path, filename)
    end
    
    defp template_file_path(name) do
      "lib/cns_forge/generators/templates/#{Macro.underscore(name)}.ex"
    end
    
    defp merge_templates(template1, template2) do
      # Implement template merging logic
      template1 <> "\\n\\n" <> template2
    end
    
    defp enhance_with_capabilities(template, capabilities) do
      Enum.reduce(capabilities, template, fn capability, acc ->
        case capability do
          :validation -> add_validation_code(acc)
          :testing -> add_testing_code(acc)
          :documentation -> add_documentation_code(acc)
          :recursion -> add_recursion_code(acc)
          _ -> acc
        end
      end)
    end
    
    # Additional helper functions for template enhancement
    defp add_validation_code(template) do
      validation_code = \"\"\"
      
      # Auto-generated validation code
      def validate_generated_code(code) do
        with :ok <- validate_syntax(code),
             :ok <- validate_dependencies(code),
             :ok <- validate_ash_compatibility(code) do
          :ok
        else
          error -> {:error, error}
        end
      end
      \"\"\"
      template <> validation_code
    end
    
    defp add_testing_code(template) do
      testing_code = \"\"\"
      
      # Auto-generated testing code
      def generate_tests(generated_code_path) do
        test_cases = extract_test_cases_from_code(generated_code_path)
        test_code = build_test_suite(test_cases)
        test_path = String.replace(generated_code_path, ".ex", "_test.exs")
        File.write!(test_path, test_code)
        {:ok, test_path}
      end
      \"\"\"
      template <> testing_code
    end
    
    defp add_documentation_code(template) do
      doc_code = \"\"\"
      
      # Auto-generated documentation code
      def generate_documentation(code_path) do
        docs = extract_documentation_from_code(code_path)
        formatted_docs = format_as_markdown(docs)
        doc_path = String.replace(code_path, ".ex", ".md")
        File.write!(doc_path, formatted_docs)
        {:ok, doc_path}
      end
      \"\"\"
      template <> doc_code
    end
    
    defp add_recursion_code(template) do
      recursion_code = \"\"\"
      
      # Auto-generated recursion capabilities
      def enable_infinite_recursion do
        @recursion_enabled true
        @max_recursion_depth :infinite
      end
      
      def recurse_with_pattern(pattern, data, depth \\ 0) do
        if recursion_should_continue?(depth) do
          transformed_data = apply_pattern(pattern, data)
          recurse_with_pattern(pattern, transformed_data, depth + 1)
        else
          data
        end
      end
      \"\"\"
      template <> recursion_code
    end
    """
  end
end