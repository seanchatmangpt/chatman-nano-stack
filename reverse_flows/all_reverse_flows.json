{
  "total_reverse_flows": 5,
  "total_execution_time": 0.801567,
  "results": {
    "k8s_reverse": {
      "reverse_flow": "k8s_to_semantics",
      "input": "kubernetes_manifests.yaml",
      "output": "inferred_domain_ontology.ttl",
      "reverse_steps": {
        "step_1": {
          "action": "Parse K8s resource definitions",
          "analysis": "Found 15 pods, 8 services, 3 ingress rules",
          "inferred": "Microservices architecture with API gateway"
        },
        "step_2": {
          "action": "Analyze service dependencies",
          "analysis": "Service mesh with 12 inter-service calls",
          "inferred": "Event-driven communication patterns"
        },
        "step_3": {
          "action": "Extract semantic relationships",
          "analysis": "Pod labels reveal domain structure",
          "inferred": "Three main domains: Users, Orders, Inventory"
        },
        "step_4": {
          "action": "Generate domain ontology",
          "analysis": "Create TTL from infrastructure patterns",
          "inferred": "Complete semantic model with 45 classes"
        }
      },
      "reverse_engineering_metrics": {
        "containers_analyzed": 15,
        "services_mapped": 8,
        "relationships_discovered": 23,
        "semantic_classes_inferred": 45,
        "confidence_level": "85%"
      },
      "use_cases": [
        "Legacy system documentation",
        "Compliance and governance",
        "System understanding and migration",
        "Architecture discovery"
      ]
    },
    "bitactor_reverse": {
      "reverse_flow": "bitactor_to_ontology",
      "input": "bitactor_c_code.c",
      "output": "actor_semantics.ttl",
      "reverse_steps": {
        "step_1": {
          "action": "Parse C actor message structures",
          "analysis": "Found 12 message types, 8 actor types",
          "inferred": "Message-passing concurrency model"
        },
        "step_2": {
          "action": "Analyze message flow patterns",
          "analysis": "Request-response and publish-subscribe patterns",
          "inferred": "Hierarchical actor supervision"
        },
        "step_3": {
          "action": "Extract semantic entities from messages",
          "analysis": "Message payloads reveal data structures",
          "inferred": "Domain entities: Market, Order, Position"
        },
        "step_4": {
          "action": "Generate TTL from actor interactions",
          "analysis": "Actor communication defines relationships",
          "inferred": "High-frequency trading domain model"
        }
      },
      "performance_preservation": {
        "original_latency": "800ns",
        "reverse_engineered_accuracy": "92%",
        "semantic_completeness": "78%",
        "information_loss": "minimal"
      },
      "advantages": [
        "Preserves performance characteristics",
        "Documents actor interactions",
        "Enables formal verification",
        "Supports system evolution"
      ]
    },
    "ash_reverse": {
      "reverse_flow": "ash_to_ttl",
      "input": "ash_resources.ex",
      "output": "api_domain_ontology.ttl",
      "reverse_steps": {
        "step_1": {
          "action": "Parse Ash resource definitions",
          "analysis": "15 resources, 45 attributes, 23 relationships",
          "inferred": "Rich domain model with complex relationships"
        },
        "step_2": {
          "action": "Extract attribute types and constraints",
          "analysis": "Type information and validation rules",
          "inferred": "SHACL shapes for data validation"
        },
        "step_3": {
          "action": "Analyze GraphQL schema generation",
          "analysis": "Query and mutation patterns",
          "inferred": "API usage patterns and access control"
        },
        "step_4": {
          "action": "Generate comprehensive TTL",
          "analysis": "Include OWL classes and properties",
          "inferred": "W3C compliant domain ontology"
        }
      },
      "api_analysis": {
        "graphql_queries": 34,
        "rest_endpoints": 67,
        "mutations": 23,
        "subscriptions": 12,
        "semantic_accuracy": "94%"
      },
      "benefits": [
        "API documentation from code",
        "Schema evolution tracking",
        "Interoperability with semantic web",
        "Automated API testing"
      ]
    },
    "reactor_reverse": {
      "reverse_flow": "reactor_to_requirements",
      "input": "reactor_workflows.ex",
      "output": "business_requirements.md",
      "reverse_steps": {
        "step_1": {
          "action": "Parse workflow step definitions",
          "analysis": "18 workflows, 144 steps, 67 error handlers",
          "inferred": "Complex business process orchestration"
        },
        "step_2": {
          "action": "Analyze step dependencies and conditions",
          "analysis": "Conditional flows and compensation actions",
          "inferred": "Business rules and exception handling"
        },
        "step_3": {
          "action": "Extract semantic meaning from step names",
          "analysis": "Natural language processing of step descriptions",
          "inferred": "Business domain vocabulary and concepts"
        },
        "step_4": {
          "action": "Generate requirements documentation",
          "analysis": "Workflow patterns reveal business needs",
          "inferred": "Comprehensive business requirements"
        }
      },
      "process_analysis": {
        "business_processes": 18,
        "decision_points": 34,
        "error_scenarios": 67,
        "compensation_flows": 23,
        "requirements_coverage": "87%"
      },
      "applications": [
        "Business process documentation",
        "Compliance auditing",
        "Process optimization",
        "Knowledge extraction"
      ]
    },
    "dspy_reverse": {
      "reverse_flow": "dspy_to_concepts",
      "input": "dspy_signatures.py",
      "output": "ai_domain_concepts.ttl",
      "reverse_steps": {
        "step_1": {
          "action": "Parse DSPy signature definitions",
          "analysis": "25 signatures, 78 input fields, 34 output fields",
          "inferred": "AI task decomposition and data flow"
        },
        "step_2": {
          "action": "Analyze field types and descriptions",
          "analysis": "Type annotations and semantic descriptions",
          "inferred": "Domain-specific AI vocabulary"
        },
        "step_3": {
          "action": "Extract prompt patterns and templates",
          "analysis": "LLM interaction patterns and optimization",
          "inferred": "AI reasoning and inference patterns"
        },
        "step_4": {
          "action": "Generate AI domain ontology",
          "analysis": "Semantic representation of AI capabilities",
          "inferred": "Machine-readable AI task definitions"
        }
      },
      "ai_analysis": {
        "ai_tasks_identified": 25,
        "llm_providers": 4,
        "prompt_patterns": 67,
        "reasoning_chains": 15,
        "semantic_accuracy": "89%"
      },
      "value_propositions": [
        "AI system documentation",
        "Prompt optimization tracking",
        "AI capability discovery",
        "Model performance analysis"
      ]
    }
  }
}