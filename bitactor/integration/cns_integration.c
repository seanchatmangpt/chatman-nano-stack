/*
 * BitActor CNS Pipeline Integration
 * Integrates BitActor bytecode execution with CNS tick pipeline
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <time.h>

#include "../include/bitactor/bitactor.h"
#include "../runtime/bytecode_loader.h"
#include "../../src/cns/cns_pipeline.h"

// Integration configuration
#define MAX_LOADED_HANDLERS    64
#define BYTECODE_CACHE_SIZE    (256 * 1024)  // 256KB cache
#define TICK_VALIDATION_SAMPLES 1000

// Loaded handler registry
typedef struct {
    uint8_t signal_kind;
    uint8_t* bytecode;
    size_t bytecode_size;
    uint32_t load_hash;
    uint64_t execution_count;
    uint64_t total_ticks;
    uint64_t max_ticks;
    bool validated;
} loaded_handler_t;

// Integration state
typedef struct {
    bitactor_engine_t* engine;
    loaded_handler_t handlers[MAX_LOADED_HANDLERS];
    uint32_t handler_count;
    uint8_t bytecode_cache[BYTECODE_CACHE_SIZE];
    size_t cache_used;
    
    // Performance metrics
    uint64_t total_executions;
    uint64_t tick_violations;
    uint64_t avg_execution_ticks;
    
    // Validation state
    bool validation_enabled;
    uint32_t validation_samples;
} cns_bitactor_t;

static cns_bitactor_t g_integration = {0};

// Forward declarations
static int validate_8tick_compliance(const loaded_handler_t* handler);
static void update_performance_metrics(loaded_handler_t* handler, uint8_t ticks);
static int load_ontology_bytecode(const char* ontology_file);

/**
 * Initialize BitActor integration with CNS pipeline
 */
int cns_bitactor_init(void) {
    // Initialize BitActor engine
    g_integration.engine = bitactor_init();
    if (!g_integration.engine) {
        return -1;
    }
    
    g_integration.validation_enabled = true;
    g_integration.validation_samples = TICK_VALIDATION_SAMPLES;
    
    printf("BitActor CNS integration initialized\n");
    return 0;
}

/**
 * Load TTL/SHACL ontology and compile to bytecode handlers
 */
int cns_bitactor_load_ontology(const char* ttl_file, const char* shacl_file) {
    char cmd[1024];
    
    // Compile ontology to bytecode using Python compiler
    snprintf(cmd, sizeof(cmd), 
             "cd /Users/sac/cns/bitactor/compiler && "
             "python bitactor_compiler.py %s %s",
             ttl_file, shacl_file ? shacl_file : "");
    
    int result = system(cmd);
    if (result != 0) {
        printf("Failed to compile ontology: %s\n", ttl_file);
        return -1;
    }
    
    // Load generated bytecode files
    return load_ontology_bytecode("generated/bytecode");
}

/**
 * Load compiled bytecode handlers from directory
 */
static int load_ontology_bytecode(const char* bytecode_dir) {
    char bytecode_file[512];
    snprintf(bytecode_file, sizeof(bytecode_file), "%s/bitactor_core.bit", bytecode_dir);
    
    // Load main bytecode file
    uint8_t* bytecode = NULL;
    size_t bytecode_size = 0;
    
    if (bitactor_load_bytecode(bytecode_file, &bytecode, &bytecode_size) != 0) {
        printf("Failed to load bytecode: %s\n", bytecode_file);
        return -1;
    }
    
    // Validate bytecode format and tick budget
    if (bitactor_validate_bytecode(bytecode, bytecode_size) != 0) {
        printf("Invalid bytecode format: %s\n", bytecode_file);
        free(bytecode);
        return -1;
    }
    
    uint8_t max_ticks = 0;
    if (bitactor_analyze_tick_budget(bytecode, bytecode_size, &max_ticks) != 0) {
        printf("Failed to analyze tick budget: %s\n", bytecode_file);
        free(bytecode);
        return -1;
    }
    
    if (max_ticks > BITACTOR_TICK_BUDGET) {
        printf("Tick budget exceeded: %d > %d in %s\n", 
               max_ticks, BITACTOR_TICK_BUDGET, bytecode_file);
        free(bytecode);
        return -1;
    }
    
    // Store in cache if there's space
    if (g_integration.cache_used + bytecode_size <= BYTECODE_CACHE_SIZE) {
        memcpy(g_integration.bytecode_cache + g_integration.cache_used, 
               bytecode, bytecode_size);
        
        // Register handler
        if (g_integration.handler_count < MAX_LOADED_HANDLERS) {
            loaded_handler_t* handler = &g_integration.handlers[g_integration.handler_count];
            handler->signal_kind = 0x01;  // Default signal kind
            handler->bytecode = g_integration.bytecode_cache + g_integration.cache_used;
            handler->bytecode_size = bytecode_size;
            handler->load_hash = (uint32_t)time(NULL);  // Simple hash
            handler->validated = false;
            
            g_integration.cache_used += bytecode_size;
            g_integration.handler_count++;
            
            // Install handler in engine
            bitactor_install_handler(g_integration.engine, handler->signal_kind,
                                   handler->bytecode, handler->bytecode_size);
            
            printf("Loaded BitActor handler: signal_kind=0x%02X, size=%zu, max_ticks=%d\n",
                   handler->signal_kind, bytecode_size, max_ticks);
        }
    }
    
    free(bytecode);
    return 0;
}

/**
 * Process signal through BitActor engine with CNS integration
 */
result_t cns_bitactor_process_signal(signal_t* signal) {
    if (!g_integration.engine) {
        result_t error_result = {0};
        error_result.status = BITACTOR_INVALID_SIGNAL;
        return error_result;
    }
    
    // Find handler for signal type
    loaded_handler_t* handler = NULL;
    for (uint32_t i = 0; i < g_integration.handler_count; i++) {
        if (g_integration.handlers[i].signal_kind == signal->kind) {
            handler = &g_integration.handlers[i];
            break;
        }
    }
    
    if (!handler) {
        result_t error_result = {0};
        error_result.status = BITACTOR_NO_HANDLER;
        return error_result;
    }
    
    // Execute bytecode with telemetry
    uint8_t scratch[BITACTOR_SCRATCH_SIZE] = {0};
    result_t result = bitactor_execute_bytecode(signal, handler->bytecode,
                                               handler->bytecode_size, scratch);
    
    // Update performance metrics
    update_performance_metrics(handler, result.ticks);
    g_integration.total_executions++;
    
    // Validate 8-tick compliance if enabled
    if (g_integration.validation_enabled && !handler->validated) {
        if (validate_8tick_compliance(handler) == 0) {
            handler->validated = true;
            printf("Handler 0x%02X validated for 8-tick compliance\n", handler->signal_kind);
        }
    }
    
    // Check for tick budget violations
    if (result.ticks > BITACTOR_TICK_BUDGET) {
        g_integration.tick_violations++;
        printf("WARNING: Tick budget exceeded: %d > %d for signal 0x%02X\n",
               result.ticks, BITACTOR_TICK_BUDGET, signal->kind);
    }
    
    return result;
}

/**
 * Integrate with CNS 8-tick pipeline
 */
int cns_bitactor_tick_integration(cns_pipeline_t* pipeline) {
    if (!pipeline || !g_integration.engine) {
        return -1;
    }
    
    // Process pending signals in pipeline
    signal_t* signal = NULL;
    while ((signal = cns_pipeline_get_next_signal(pipeline)) != NULL) {
        result_t result = cns_bitactor_process_signal(signal);
        
        // Feed result back to CNS pipeline
        if (result.status == BITACTOR_OK) {
            cns_pipeline_set_result(pipeline, signal->id, result.result);
        } else {
            cns_pipeline_set_error(pipeline, signal->id, result.status);
        }
        
        // Enforce tick budget at pipeline level
        if (result.ticks > BITACTOR_TICK_BUDGET) {
            printf("Pipeline tick budget violation: handler took %d ticks\n", result.ticks);
            return -1;  // Pipeline failure
        }
    }
    
    return 0;
}

/**
 * Validate 8-tick compliance through statistical sampling
 */
static int validate_8tick_compliance(const loaded_handler_t* handler) {
    uint32_t violations = 0;
    uint64_t total_ticks = 0;
    uint32_t samples = g_integration.validation_samples;
    
    printf("Validating 8-tick compliance for handler 0x%02X (%d samples)...\n",
           handler->signal_kind, samples);
    
    for (uint32_t i = 0; i < samples; i++) {
        // Generate test signal
        signal_t test_signal = {
            .id = i,
            .kind = handler->signal_kind,
            .priority = 128,
            .flags = 0,
            .payload = (uint64_t)rand() << 32 | rand(),
            .timestamp = __rdtsc(),
            .context = 0
        };
        
        // Execute and measure
        uint8_t scratch[BITACTOR_SCRATCH_SIZE] = {0};
        result_t result = bitactor_execute_bytecode(&test_signal, handler->bytecode,
                                                   handler->bytecode_size, scratch);
        
        total_ticks += result.ticks;
        
        if (result.ticks > BITACTOR_TICK_BUDGET) {
            violations++;
        }
        
        // Early exit if too many violations
        if (violations > samples / 100) {  // More than 1% violations
            printf("FAILED: %d violations in %d samples (%.2f%%)\n",
                   violations, i + 1, (float)violations * 100.0f / (i + 1));
            return -1;
        }
    }
    
    float avg_ticks = (float)total_ticks / samples;
    float violation_rate = (float)violations * 100.0f / samples;
    
    printf("PASSED: avg_ticks=%.2f, violations=%d/%d (%.3f%%)\n",
           avg_ticks, violations, samples, violation_rate);
    
    return (violation_rate < 0.1f) ? 0 : -1;  // Allow < 0.1% violations
}

/**
 * Update performance metrics for handler
 */
static void update_performance_metrics(loaded_handler_t* handler, uint8_t ticks) {
    handler->execution_count++;
    handler->total_ticks += ticks;
    if (ticks > handler->max_ticks) {
        handler->max_ticks = ticks;
    }
    
    // Update global averages
    g_integration.avg_execution_ticks = 
        (g_integration.avg_execution_ticks * (g_integration.total_executions - 1) + ticks) /
        g_integration.total_executions;
}

/**
 * Generate performance report
 */
void cns_bitactor_performance_report(FILE* output) {
    fprintf(output, "BitActor CNS Integration Performance Report\n");
    fprintf(output, "==========================================\n");
    fprintf(output, "Total executions: %lu\n", g_integration.total_executions);
    fprintf(output, "Tick violations: %lu (%.3f%%)\n", 
            g_integration.tick_violations,
            (float)g_integration.tick_violations * 100.0f / g_integration.total_executions);
    fprintf(output, "Average ticks: %lu\n", g_integration.avg_execution_ticks);
    fprintf(output, "Loaded handlers: %d\n", g_integration.handler_count);
    fprintf(output, "Cache usage: %zu / %d bytes (%.1f%%)\n",
            g_integration.cache_used, BYTECODE_CACHE_SIZE,
            (float)g_integration.cache_used * 100.0f / BYTECODE_CACHE_SIZE);
    
    fprintf(output, "\nHandler Statistics:\n");
    for (uint32_t i = 0; i < g_integration.handler_count; i++) {
        loaded_handler_t* h = &g_integration.handlers[i];
        float avg_ticks = h->execution_count > 0 ? 
                         (float)h->total_ticks / h->execution_count : 0.0f;
        
        fprintf(output, "  Handler 0x%02X: exec=%lu, avg_ticks=%.2f, max_ticks=%lu, validated=%s\n",
                h->signal_kind, h->execution_count, avg_ticks, h->max_ticks,
                h->validated ? "YES" : "NO");
    }
    
    fprintf(output, "\n8-Tick Compliance: %s\n",
            g_integration.tick_violations == 0 ? "COMPLIANT" : "VIOLATIONS DETECTED");
}

/**
 * Cleanup integration
 */
void cns_bitactor_cleanup(void) {
    if (g_integration.engine) {
        bitactor_destroy(g_integration.engine);
        g_integration.engine = NULL;
    }
    
    memset(&g_integration, 0, sizeof(g_integration));
    printf("BitActor CNS integration cleaned up\n");
}