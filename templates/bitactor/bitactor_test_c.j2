/**
 * BitActor Unit Tests - Generated from {{ ontology_name }}
 * Test 8-tick performance guarantee and signal processing
 * Generated by CNS Jinja AOT Compiler
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>
#include <string.h>

#define {{ prefix|upper }}_IMPLEMENTATION
#include "{{ prefix }}_bitactor.h"

/* Test utilities */
static uint64_t get_timestamp_ns() {
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return ts.tv_sec * 1000000000ULL + ts.tv_nsec;
}

/* Test cases */
static void test_{{ prefix }}_init() {
    printf("Testing {{ prefix }}_bitactor_init...\n");
    
    {{ prefix }}_bitactor_t ba;
    {{ prefix }}_bitactor_init(&ba);
    
    assert(ba.signal_head == 0);
    assert(ba.signal_tail == 0);
    assert(ba.tick_count == 0);
    assert(ba.signal_count == 0);
    
{% for handler in handlers %}
    assert(ba.dispatch[{{ prefix|upper }}_SIGNAL_{{ handler.signal|upper }}] == {{ prefix }}_handle_{{ handler.name|c_identifier }});
{% endfor %}
    
    printf("✅ {{ prefix }}_bitactor_init passed\n");
}

static void test_signal_enqueue() {
    printf("Testing signal enqueue...\n");
    
    {{ prefix }}_bitactor_t ba;
    {{ prefix }}_bitactor_init(&ba);
    
    {{ prefix }}_signal_t sig = {
        .type = {{ prefix|upper }}_SIGNAL_{{ signals[0].name|upper }},
        .flags = 0,
        .timestamp = get_timestamp_ns(),
        .payload = 0xDEADBEEF
    };
    
    bool result = {{ prefix }}_bitactor_enqueue_signal(&ba, &sig);
    assert(result == true);
    assert(ba.signal_head == 1);
    
    printf("✅ Signal enqueue passed\n");
}

static void test_tick_performance() {
    printf("Testing tick performance ({{ tick_budget }}-tick budget)...\n");
    
    {{ prefix }}_bitactor_t ba;
    {{ prefix }}_bitactor_init(&ba);
    
    /* Enqueue test signals */
{% for signal in signals[:3] %}
    {{ prefix }}_signal_t sig{{ loop.index }} = {
        .type = {{ prefix|upper }}_SIGNAL_{{ signal.name|upper }},
        .flags = 0,
        .timestamp = get_timestamp_ns(),
        .payload = {{ loop.index }}
    };
    {{ prefix }}_bitactor_enqueue_signal(&ba, &sig{{ loop.index }});
{% endfor %}
    
    /* Process signals and measure performance */
    uint64_t total_ticks = 0;
    int processed = 0;
    
    while (ba.signal_head != ba.signal_tail) {
        uint64_t start = rdtsc();
        {{ prefix }}_bitactor_tick(&ba);
        uint64_t elapsed = rdtsc() - start;
        
        total_ticks += elapsed;
        processed++;
        
        /* Verify tick budget */
        assert(elapsed <= {{ prefix|upper }}_TICK_BUDGET);
    }
    
    printf("✅ Processed %d signals, avg ticks: %llu\n", processed, (unsigned long long)(total_ticks / processed));
}

static void test_ring_buffer_overflow() {
    printf("Testing ring buffer overflow protection...\n");
    
    {{ prefix }}_bitactor_t ba;
    {{ prefix }}_bitactor_init(&ba);
    
    {{ prefix }}_signal_t sig = {
        .type = {{ prefix|upper }}_SIGNAL_{{ signals[0].name|upper }},
        .flags = 0,
        .timestamp = 0,
        .payload = 0
    };
    
    /* Fill the ring buffer */
    int enqueued = 0;
    while ({{ prefix }}_bitactor_enqueue_signal(&ba, &sig)) {
        enqueued++;
        if (enqueued > {{ prefix|upper }}_RING_SIZE) {
            break; /* Safety check */
        }
    }
    
    assert(enqueued == {{ prefix|upper }}_RING_SIZE - 1);
    
    /* Verify overflow protection */
    bool result = {{ prefix }}_bitactor_enqueue_signal(&ba, &sig);
    assert(result == false);
    
    printf("✅ Ring buffer overflow protection working (capacity: %d)\n", enqueued);
}

{% for signal in signals %}
static void test_{{ signal.name|lower }}_signal() {
    printf("Testing {{ signal.label }} signal...\n");
    
    {{ prefix }}_bitactor_t ba;
    {{ prefix }}_bitactor_init(&ba);
    
    {{ prefix }}_signal_t sig = {
        .type = {{ prefix|upper }}_SIGNAL_{{ signal.name|upper }},
        .flags = 0x1234,
        .timestamp = get_timestamp_ns(),
        .payload = 0xCAFEBABE
    };
    
    {{ prefix }}_bitactor_enqueue_signal(&ba, &sig);
    {{ prefix }}_bitactor_tick(&ba);
    
    assert(ba.signal_count == 1);
    printf("✅ {{ signal.label }} signal processed\n");
}
{% endfor %}

/* Benchmark suite */
static void benchmark_throughput() {
    printf("\n=== Throughput Benchmark ===\n");
    
    {{ prefix }}_bitactor_t ba;
    {{ prefix }}_bitactor_init(&ba);
    
    const int NUM_SIGNALS = 1000000;
    uint64_t start_time = get_timestamp_ns();
    
    for (int i = 0; i < NUM_SIGNALS; i++) {
        {{ prefix }}_signal_t sig = {
            .type = (i % {{ signals|length }}) + 1,
            .flags = 0,
            .timestamp = i,
            .payload = i
        };
        
        while (!{{ prefix }}_bitactor_enqueue_signal(&ba, &sig)) {
            {{ prefix }}_bitactor_tick(&ba);
        }
        
        if (ba.signal_head == ba.signal_tail + 1) {
            {{ prefix }}_bitactor_tick(&ba);
        }
    }
    
    /* Process remaining signals */
    while (ba.signal_head != ba.signal_tail) {
        {{ prefix }}_bitactor_tick(&ba);
    }
    
    uint64_t elapsed_ns = get_timestamp_ns() - start_time;
    double throughput = (double)NUM_SIGNALS / (elapsed_ns / 1e9);
    
    printf("Processed %d signals in %.3f ms\n", NUM_SIGNALS, elapsed_ns / 1e6);
    printf("Throughput: %.2f signals/sec (%.2f MHz)\n", throughput, throughput / 1e6);
    printf("Average latency: %.2f ns/signal\n", (double)elapsed_ns / NUM_SIGNALS);
}

int main(int argc, char** argv) {
    printf("{{ prefix|upper }} BitActor Test Suite\n");
    printf("================================\n\n");
    
    /* Run unit tests */
    test_{{ prefix }}_init();
    test_signal_enqueue();
    test_tick_performance();
    test_ring_buffer_overflow();
    
{% for signal in signals %}
    test_{{ signal.name|lower }}_signal();
{% endfor %}
    
    /* Run benchmarks */
    if (argc > 1 && strcmp(argv[1], "--bench") == 0) {
        benchmark_throughput();
    }
    
    printf("\n✅ All tests passed!\n");
    return 0;
}