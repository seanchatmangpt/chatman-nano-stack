#!/usr/bin/env python3
"""
üöÄ CNS Forge 80/20 Management CLI
Typer-based CLI for managing all projects in the CNS ecosystem
Applies 80/20 principle: 20% of commands for 80% of management value
"""

import typer
import subprocess
import json
import yaml
import os
import sys
from pathlib import Path
from typing import Optional, List
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn
import time

app = typer.Typer(
    name="cns",
    help="üöÄ CNS Forge 80/20 Management CLI - Manage the entire CNS ecosystem",
    rich_markup_mode="rich"
)

console = Console()

# Core project paths
FORGE_PATH = Path(".")
BITACTOR_PATH = Path("bitactor")
NUXT_PATH = Path("nuxt-ui") 
K8S_PATH = Path("k8s")
TERRAFORM_PATH = Path("terraform")
GENERATED_PATH = Path("generated")

# ============================================================================
# üîß Core CNS Forge Commands (80/20 Priority: HIGH)
# ============================================================================

forge_app = typer.Typer(name="forge", help="üîß Manage CNS Forge core system")
app.add_typer(forge_app)

@forge_app.command("start")
def forge_start(
    env: str = typer.Option("dev", help="Environment: dev/test/prod"),
    port: int = typer.Option(4000, help="Phoenix server port")
):
    """üöÄ Start CNS Forge Phoenix server"""
    console.print(Panel("üöÄ Starting CNS Forge", style="bold green"))
    
    env_vars = {
        "MIX_ENV": env,
        "PORT": str(port)
    }
    
    with console.status("[bold green]Starting Phoenix server..."):
        result = subprocess.run(
            ["mix", "phx.server"],
            env={**os.environ, **env_vars},
            cwd=FORGE_PATH
        )
    
    if result.returncode == 0:
        console.print(f"‚úÖ CNS Forge started on port {port}")
    else:
        console.print("‚ùå Failed to start CNS Forge", style="bold red")
        raise typer.Exit(1)

@forge_app.command("test")
def forge_test(
    coverage: bool = typer.Option(True, help="Run with coverage"),
    pattern: Optional[str] = typer.Option(None, help="Test pattern filter")
):
    """üß™ Run CNS Forge tests"""
    console.print(Panel("üß™ Running CNS Forge Tests", style="bold blue"))
    
    cmd = ["mix", "test"]
    if coverage:
        cmd.append("--cover")
    if pattern:
        cmd.extend(["--only", pattern])
    
    with console.status("[bold blue]Running tests..."):
        result = subprocess.run(cmd, cwd=FORGE_PATH)
    
    if result.returncode == 0:
        console.print("‚úÖ All tests passed")
    else:
        console.print("‚ùå Tests failed", style="bold red")
        raise typer.Exit(1)

@forge_app.command("deps")
def forge_deps(
    action: str = typer.Option("get", help="Action: get/update/clean/compile")
):
    """üì¶ Manage Elixir dependencies"""
    console.print(Panel(f"üì¶ Managing dependencies: {action}", style="bold yellow"))
    
    cmd = ["mix", f"deps.{action}"]
    
    with console.status(f"[bold yellow]Running deps.{action}..."):
        result = subprocess.run(cmd, cwd=FORGE_PATH)
    
    if result.returncode == 0:
        console.print(f"‚úÖ Dependencies {action} completed")
    else:
        console.print(f"‚ùå Dependencies {action} failed", style="bold red")
        raise typer.Exit(1)

@forge_app.command("compile")
def forge_compile(
    force: bool = typer.Option(False, help="Force recompilation"),
    warnings_as_errors: bool = typer.Option(True, help="Treat warnings as errors")
):
    """‚öôÔ∏è Compile CNS Forge"""
    console.print(Panel("‚öôÔ∏è Compiling CNS Forge", style="bold cyan"))
    
    cmd = ["mix", "compile"]
    if force:
        cmd.append("--force")
    if warnings_as_errors:
        cmd.append("--warnings-as-errors")
    
    with console.status("[bold cyan]Compiling..."):
        result = subprocess.run(cmd, cwd=FORGE_PATH)
    
    if result.returncode == 0:
        console.print("‚úÖ Compilation successful")
    else:
        console.print("‚ùå Compilation failed", style="bold red")
        raise typer.Exit(1)

# ============================================================================
# ‚ö° BitActor Commands (80/20 Priority: HIGH)
# ============================================================================

bitactor_app = typer.Typer(name="bitactor", help="‚ö° Manage BitActor high-performance components")
app.add_typer(bitactor_app)

@bitactor_app.command("build")
def bitactor_build(
    optimization: str = typer.Option("O3", help="Optimization level: O0/O1/O2/O3"),
    target: str = typer.Option("all", help="Build target: all/core/forex/cybersecurity")
):
    """üî® Build BitActor C components"""
    console.print(Panel(f"üî® Building BitActor ({target})", style="bold green"))
    
    make_cmd = ["make"]
    if target != "all":
        make_cmd.append(target)
    
    env_vars = {"CFLAGS": f"-{optimization}"}
    
    with console.status("[bold green]Building BitActor..."):
        result = subprocess.run(
            make_cmd,
            env={**os.environ, **env_vars},
            cwd=BITACTOR_PATH if BITACTOR_PATH.exists() else FORGE_PATH
        )
    
    if result.returncode == 0:
        console.print(f"‚úÖ BitActor {target} built successfully")
    else:
        console.print("‚ùå BitActor build failed", style="bold red")
        raise typer.Exit(1)

@bitactor_app.command("test")
def bitactor_test(
    suite: str = typer.Option("all", help="Test suite: all/unit/integration/stress"),
    coverage: bool = typer.Option(True, help="Generate coverage report")
):
    """üß™ Run BitActor tests"""
    console.print(Panel(f"üß™ Running BitActor tests ({suite})", style="bold blue"))
    
    test_files = {
        "all": "test_*.c",
        "unit": "test_*_unit.c", 
        "integration": "test_*_integration.c",
        "stress": "test_*_stress.c"
    }
    
    pattern = test_files.get(suite, "test_*.c")
    
    cmd = ["make", "test", f"PATTERN={pattern}"]
    if coverage:
        cmd.append("coverage")
    
    with console.status(f"[bold blue]Running {suite} tests..."):
        result = subprocess.run(cmd, cwd=FORGE_PATH / "tests")
    
    if result.returncode == 0:
        console.print(f"‚úÖ BitActor {suite} tests passed")
    else:
        console.print("‚ùå BitActor tests failed", style="bold red")
        raise typer.Exit(1)

@bitactor_app.command("benchmark")
def bitactor_benchmark(
    type: str = typer.Option("performance", help="Benchmark type: performance/memory/latency"),
    iterations: int = typer.Option(1000, help="Number of iterations")
):
    """üìä Run BitActor benchmarks"""
    console.print(Panel(f"üìä Running {type} benchmark", style="bold yellow"))
    
    benchmark_map = {
        "performance": "benchmark_v8_system",
        "memory": "test_memory_stress_bdd",
        "latency": "test_tick_parallel_bdd"
    }
    
    binary = benchmark_map.get(type, "benchmark_v8_system")
    
    with console.status(f"[bold yellow]Running {iterations} iterations..."):
        result = subprocess.run([f"./{binary}", str(iterations)], cwd=FORGE_PATH)
    
    if result.returncode == 0:
        console.print(f"‚úÖ {type} benchmark completed")
    else:
        console.print("‚ùå Benchmark failed", style="bold red")
        raise typer.Exit(1)

# ============================================================================
# üîÑ Ash Reactor Commands (80/20 Priority: HIGH)
# ============================================================================

reactor_app = typer.Typer(name="reactor", help="üîÑ Manage Ash Reactor workflows")
app.add_typer(reactor_app)

@reactor_app.command("run")
def reactor_run(
    workflow: str = typer.Argument(..., help="Reactor workflow to execute"),
    args: Optional[str] = typer.Option(None, help="JSON arguments for workflow"),
    dry_run: bool = typer.Option(False, help="Validate without executing")
):
    """üîÑ Execute Ash Reactor workflow"""
    console.print(Panel(f"üîÑ Running Reactor: {workflow}", style="bold green"))
    
    script_content = f"""
    alias CnsForge.ReactorWorkflows.{workflow.title()}Reactor
    
    args = {args or "{}"}
    
    {"# DRY RUN MODE" if dry_run else ""}
    case {workflow.title()}Reactor.run(args) do
      {{:ok, result}} -> 
        IO.puts("‚úÖ Workflow completed: {{inspect(result)}}")
      {{:error, reason}} -> 
        IO.puts("‚ùå Workflow failed: {{inspect(reason)}}")
        System.halt(1)
    end
    """
    
    with console.status(f"[bold green]Executing {workflow}..."):
        result = subprocess.run(
            ["mix", "run", "-e", script_content],
            cwd=FORGE_PATH
        )
    
    if result.returncode == 0:
        console.print(f"‚úÖ Reactor {workflow} completed")
    else:
        console.print("‚ùå Reactor failed", style="bold red")
        raise typer.Exit(1)

@reactor_app.command("list")
def reactor_list():
    """üìã List available Reactor workflows"""
    console.print(Panel("üìã Available Reactor Workflows", style="bold blue"))
    
    # Scan for reactor files
    reactor_files = list(Path("lib").glob("**/*reactor*.ex"))
    
    table = Table(title="Reactor Workflows")
    table.add_column("Name", style="cyan")
    table.add_column("File", style="green") 
    table.add_column("Status", style="yellow")
    
    for file in reactor_files:
        name = file.stem.replace("_reactor", "")
        status = "‚úÖ Active" if file.exists() else "‚ùå Missing"
        table.add_row(name, str(file), status)
    
    console.print(table)

@reactor_app.command("validate")
def reactor_validate(
    workflow: Optional[str] = typer.Option(None, help="Specific workflow to validate")
):
    """‚úÖ Validate Reactor workflow definitions"""
    console.print(Panel("‚úÖ Validating Reactor workflows", style="bold yellow"))
    
    cmd = ["mix", "test", "test/cns_forge/*reactor*test.exs"]
    if workflow:
        cmd.append(f"--only=reactor:{workflow}")
    
    with console.status("[bold yellow]Validating workflows..."):
        result = subprocess.run(cmd, cwd=FORGE_PATH)
    
    if result.returncode == 0:
        console.print("‚úÖ All workflows valid")
    else:
        console.print("‚ùå Workflow validation failed", style="bold red")
        raise typer.Exit(1)

# ============================================================================
# üß† Semantic/TTL Commands (80/20 Priority: MEDIUM)
# ============================================================================

semantic_app = typer.Typer(name="semantic", help="üß† Manage semantic processing and TTL workflows")
app.add_typer(semantic_app)

@semantic_app.command("generate")
def semantic_generate(
    input_file: str = typer.Argument(..., help="Input TTL/RDF file"),
    output_type: str = typer.Option("dspy", help="Output: dspy/bitactor/ash/all"),
    validate: bool = typer.Option(True, help="Validate generated output")
):
    """üîÑ Generate code from TTL/semantic definitions"""
    console.print(Panel(f"üîÑ Generating {output_type} from {input_file}", style="bold green"))
    
    generators = {
        "dspy": "ttl2dspy.py",
        "bitactor": "bitactor_ttl_generator.py", 
        "ash": "ttl_to_ash_generator.py",
        "all": "pipeline_validator.py"
    }
    
    generator = generators.get(output_type, "ttl2dspy.py")
    
    with console.status(f"[bold green]Generating {output_type}..."):
        result = subprocess.run([
            "python", generator, input_file, 
            "--validate" if validate else "--no-validate"
        ])
    
    if result.returncode == 0:
        console.print(f"‚úÖ {output_type} generated successfully")
    else:
        console.print("‚ùå Generation failed", style="bold red")
        raise typer.Exit(1)

@semantic_app.command("validate")
def semantic_validate(
    file: str = typer.Argument(..., help="TTL/RDF file to validate"),
    schema: Optional[str] = typer.Option(None, help="SHACL schema file")
):
    """‚úÖ Validate TTL/RDF semantic definitions"""
    console.print(Panel(f"‚úÖ Validating {file}", style="bold blue"))
    
    cmd = ["python", "scripts/validate_ttl.py", file]
    if schema:
        cmd.extend(["--schema", schema])
    
    with console.status("[bold blue]Validating semantics..."):
        result = subprocess.run(cmd)
    
    if result.returncode == 0:
        console.print("‚úÖ Semantic validation passed")
    else:
        console.print("‚ùå Semantic validation failed", style="bold red")
        raise typer.Exit(1)

@semantic_app.command("ontology")
def semantic_ontology(
    action: str = typer.Option("list", help="Action: list/generate/validate/compile"),
    domain: Optional[str] = typer.Option(None, help="Domain: cybersecurity/healthcare/automotive/etc")
):
    """üß† Manage ontology definitions"""
    console.print(Panel(f"üß† Ontology {action}", style="bold cyan"))
    
    if action == "list":
        ontology_files = list(Path("ontologies").glob("*.ttl"))
        table = Table(title="Available Ontologies")
        table.add_column("Domain", style="cyan")
        table.add_column("File", style="green")
        table.add_column("Size", style="yellow")
        
        for file in ontology_files:
            domain = file.stem.replace("_core", "").replace("_shacl", "")
            size = f"{file.stat().st_size // 1024}KB"
            table.add_row(domain, file.name, size)
        
        console.print(table)
    
    elif action == "generate":
        if not domain:
            console.print("‚ùå Domain required for generation", style="bold red")
            raise typer.Exit(1)
        
        with console.status(f"[bold cyan]Generating {domain} ontology..."):
            result = subprocess.run([
                "python", "ontology_forge_cli.py", "generate", 
                "--domain", domain
            ])
        
        if result.returncode == 0:
            console.print(f"‚úÖ {domain} ontology generated")
        else:
            console.print("‚ùå Ontology generation failed", style="bold red")
            raise typer.Exit(1)

# ============================================================================
# üñ•Ô∏è Nuxt UI Commands (80/20 Priority: MEDIUM)
# ============================================================================

nuxt_app = typer.Typer(name="nuxt", help="üñ•Ô∏è Manage Nuxt UI frontend")
app.add_typer(nuxt_app)

@nuxt_app.command("dev")
def nuxt_dev(
    port: int = typer.Option(3000, help="Development server port"),
    open_browser: bool = typer.Option(True, help="Open browser automatically")
):
    """üöÄ Start Nuxt development server"""
    console.print(Panel("üöÄ Starting Nuxt dev server", style="bold green"))
    
    cmd = ["npm", "run", "dev", "--", "--port", str(port)]
    if open_browser:
        cmd.extend(["--open"])
    
    nuxt_path = NUXT_PATH if NUXT_PATH.exists() else Path("nuxt-ui") or Path("aegis-nuxt")
    
    with console.status("[bold green]Starting Nuxt..."):
        result = subprocess.run(cmd, cwd=nuxt_path)
    
    if result.returncode == 0:
        console.print(f"‚úÖ Nuxt started on port {port}")
    else:
        console.print("‚ùå Failed to start Nuxt", style="bold red")
        raise typer.Exit(1)

@nuxt_app.command("build")
def nuxt_build(
    target: str = typer.Option("static", help="Build target: static/server/spa"),
    analyze: bool = typer.Option(False, help="Analyze bundle size")
):
    """üî® Build Nuxt for production"""
    console.print(Panel(f"üî® Building Nuxt ({target})", style="bold blue"))
    
    cmd = ["npm", "run", "build"]
    if analyze:
        cmd = ["npm", "run", "build:analyze"]
    
    nuxt_path = NUXT_PATH if NUXT_PATH.exists() else Path("aegis-nuxt")
    
    with console.status("[bold blue]Building Nuxt..."):
        result = subprocess.run(cmd, cwd=nuxt_path)
    
    if result.returncode == 0:
        console.print("‚úÖ Nuxt build completed")
    else:
        console.print("‚ùå Nuxt build failed", style="bold red")
        raise typer.Exit(1)

@nuxt_app.command("test")
def nuxt_test(
    type: str = typer.Option("unit", help="Test type: unit/e2e/cypress"),
    coverage: bool = typer.Option(True, help="Generate coverage report")
):
    """üß™ Run Nuxt tests"""
    console.print(Panel(f"üß™ Running Nuxt {type} tests", style="bold yellow"))
    
    test_commands = {
        "unit": "npm run test:unit",
        "e2e": "npm run test:e2e", 
        "cypress": "npx cypress run"
    }
    
    cmd = test_commands.get(type, "npm run test").split()
    if coverage and type == "unit":
        cmd.append("--coverage")
    
    nuxt_path = NUXT_PATH if NUXT_PATH.exists() else Path("cypress_pipeline_tests")
    
    with console.status(f"[bold yellow]Running {type} tests..."):
        result = subprocess.run(cmd, cwd=nuxt_path)
    
    if result.returncode == 0:
        console.print(f"‚úÖ Nuxt {type} tests passed")
    else:
        console.print("‚ùå Nuxt tests failed", style="bold red")
        raise typer.Exit(1)

# ============================================================================
# ‚ò∏Ô∏è Infrastructure Commands (80/20 Priority: MEDIUM)
# ============================================================================

infra_app = typer.Typer(name="infra", help="‚ò∏Ô∏è Manage K8s and infrastructure")
app.add_typer(infra_app)

@infra_app.command("deploy")
def infra_deploy(
    environment: str = typer.Option("dev", help="Environment: dev/staging/prod"),
    component: str = typer.Option("all", help="Component: all/cns-forge/bitactor/nuxt"),
    dry_run: bool = typer.Option(False, help="Validate without applying")
):
    """üöÄ Deploy to Kubernetes"""
    console.print(Panel(f"üöÄ Deploying {component} to {environment}", style="bold green"))
    
    k8s_files = {
        "all": "k8s/*.yaml",
        "cns-forge": "k8s/cns-forge-deployment.yaml",
        "bitactor": "bitactor-k8s-deployment.yaml", 
        "nuxt": "k8s/nuxt-ui-deployment.yaml"
    }
    
    file_pattern = k8s_files.get(component, "k8s/*.yaml")
    
    cmd = ["kubectl", "apply", "-f", file_pattern]
    if dry_run:
        cmd.append("--dry-run=client")
    
    with console.status(f"[bold green]Deploying {component}..."):
        result = subprocess.run(cmd)
    
    if result.returncode == 0:
        console.print(f"‚úÖ {component} deployed to {environment}")
    else:
        console.print("‚ùå Deployment failed", style="bold red")
        raise typer.Exit(1)

@infra_app.command("status")
def infra_status(
    namespace: str = typer.Option("default", help="Kubernetes namespace"),
    output: str = typer.Option("table", help="Output format: table/json/yaml")
):
    """üìä Check infrastructure status"""
    console.print(Panel(f"üìä Infrastructure Status ({namespace})", style="bold blue"))
    
    resources = ["pods", "services", "deployments", "ingress"]
    
    for resource in resources:
        console.print(f"\n[bold cyan]{resource.title()}:[/bold cyan]")
        
        cmd = ["kubectl", "get", resource, "-n", namespace]
        if output != "table":
            cmd.extend(["-o", output])
        
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            console.print(result.stdout)
        else:
            console.print(f"‚ùå Failed to get {resource}", style="bold red")

@infra_app.command("terraform")
def infra_terraform(
    action: str = typer.Option("plan", help="Action: init/plan/apply/destroy"),
    environment: str = typer.Option("dev", help="Environment: dev/staging/prod"),
    auto_approve: bool = typer.Option(False, help="Auto-approve changes")
):
    """üèóÔ∏è Manage Terraform infrastructure"""
    console.print(Panel(f"üèóÔ∏è Terraform {action} ({environment})", style="bold yellow"))
    
    terraform_dir = TERRAFORM_PATH if TERRAFORM_PATH.exists() else Path(".")
    
    cmd = ["terraform", action]
    if action in ["apply", "destroy"] and auto_approve:
        cmd.append("-auto-approve")
    
    env_vars = {"TF_VAR_environment": environment}
    
    with console.status(f"[bold yellow]Running terraform {action}..."):
        result = subprocess.run(
            cmd,
            env={**os.environ, **env_vars},
            cwd=terraform_dir
        )
    
    if result.returncode == 0:
        console.print(f"‚úÖ Terraform {action} completed")
    else:
        console.print("‚ùå Terraform failed", style="bold red")
        raise typer.Exit(1)

# ============================================================================
# üß™ Testing Commands (80/20 Priority: HIGH)
# ============================================================================

test_app = typer.Typer(name="test", help="üß™ Comprehensive testing suite")
app.add_typer(test_app)

@test_app.command("all")
def test_all(
    coverage: bool = typer.Option(True, help="Generate coverage reports"),
    parallel: bool = typer.Option(True, help="Run tests in parallel"),
    output_format: str = typer.Option("pretty", help="Output: pretty/json/junit")
):
    """üöÄ Run complete test suite (80/20 approach)"""
    console.print(Panel("üöÄ Running Complete Test Suite", style="bold green"))
    
    # 80/20 critical tests
    test_suites = [
        ("Elixir Unit Tests", ["mix", "test", "--cover"]),
        ("BitActor Core Tests", ["make", "test", "PATTERN=test_bitactor_core*.c"]),
        ("Reactor Workflow Tests", ["mix", "test", "test/cns_forge/*reactor*test.exs"]),
        ("K8s Deployment Tests", ["kubectl", "apply", "--dry-run=client", "-f", "k8s/"]),
        ("Integration Tests", ["python", "comprehensive_integration_validator.exs"])
    ]
    
    results = {}
    
    with Progress(
        SpinnerColumn(),
        TextColumn("[progress.description]{task.description}"),
        console=console
    ) as progress:
        
        for name, cmd in test_suites:
            task = progress.add_task(f"Running {name}...", total=None)
            
            result = subprocess.run(cmd, capture_output=True, text=True)
            results[name] = {
                "success": result.returncode == 0,
                "output": result.stdout,
                "errors": result.stderr
            }
            
            progress.update(task, completed=True)
    
    # Results summary
    table = Table(title="Test Results Summary")
    table.add_column("Test Suite", style="cyan")
    table.add_column("Status", style="green")
    table.add_column("Details", style="yellow")
    
    for name, result in results.items():
        status = "‚úÖ PASS" if result["success"] else "‚ùå FAIL"
        details = "OK" if result["success"] else "Check logs"
        table.add_row(name, status, details)
    
    console.print(table)
    
    # Overall result
    all_passed = all(r["success"] for r in results.values())
    if all_passed:
        console.print("‚úÖ All critical tests passed!", style="bold green")
    else:
        console.print("‚ùå Some tests failed", style="bold red")
        raise typer.Exit(1)

@test_app.command("coverage")
def test_coverage(
    minimum: float = typer.Option(80.0, help="Minimum coverage percentage"),
    report_format: str = typer.Option("html", help="Format: html/json/lcov")
):
    """üìä Generate comprehensive coverage report"""
    console.print(Panel("üìä Generating Coverage Report", style="bold blue"))
    
    with console.status("[bold blue]Collecting coverage data..."):
        # Run tests with coverage
        subprocess.run(["mix", "test", "--cover"], cwd=FORGE_PATH)
        subprocess.run(["make", "coverage"], cwd=Path("tests"))
        subprocess.run(["npm", "run", "test:coverage"], cwd=NUXT_PATH if NUXT_PATH.exists() else Path("."))
    
    console.print(f"‚úÖ Coverage report generated in {report_format} format")

# ============================================================================
# üìä Monitoring/OTEL Commands (80/20 Priority: MEDIUM) 
# ============================================================================

monitor_app = typer.Typer(name="monitor", help="üìä Monitoring and observability")
app.add_typer(monitor_app)

@monitor_app.command("otel")
def monitor_otel(
    component: str = typer.Option("all", help="Component: all/forge/bitactor/nuxt"),
    duration: int = typer.Option(60, help="Monitoring duration in seconds"),
    export_format: str = typer.Option("json", help="Export format: json/prometheus/jaeger")
):
    """üì° Collect OTEL telemetry data"""
    console.print(Panel(f"üì° Collecting OTEL data for {component}", style="bold cyan"))
    
    scripts = {
        "all": "otel_instrumentation_suite.py",
        "forge": "ash_reactor_otel_validation_engine.py",
        "bitactor": "validate_otel.py",
        "nuxt": "nuxt_80_20_otel_validation.py"
    }
    
    script = scripts.get(component, "otel_instrumentation_suite.py")
    
    with console.status(f"[bold cyan]Collecting data for {duration}s..."):
        result = subprocess.run([
            "python", script, 
            "--duration", str(duration),
            "--format", export_format
        ])
    
    if result.returncode == 0:
        console.print(f"‚úÖ OTEL data collected and exported as {export_format}")
    else:
        console.print("‚ùå OTEL collection failed", style="bold red")
        raise typer.Exit(1)

@monitor_app.command("metrics")
def monitor_metrics(
    metric_type: str = typer.Option("performance", help="Type: performance/business/system"),
    timeframe: str = typer.Option("1h", help="Timeframe: 1h/24h/7d/30d")
):
    """üìà Display system metrics"""
    console.print(Panel(f"üìà {metric_type.title()} Metrics ({timeframe})", style="bold yellow"))
    
    # Mock metrics display - in real implementation would query monitoring system
    metrics_data = {
        "performance": ["Latency: 45ms", "Throughput: 1200 req/s", "Error Rate: 0.1%"],
        "business": ["Active Users: 1,250", "Revenue: $12,500", "Conversion: 3.2%"],
        "system": ["CPU: 65%", "Memory: 2.1GB", "Disk: 45%"]
    }
    
    table = Table(title=f"{metric_type.title()} Metrics")
    table.add_column("Metric", style="cyan")
    table.add_column("Value", style="green")
    table.add_column("Status", style="yellow")
    
    for metric in metrics_data.get(metric_type, []):
        name, value = metric.split(": ")
        status = "‚úÖ Good" if "Error" not in metric else "‚ö†Ô∏è Watch"
        table.add_row(name, value, status)
    
    console.print(table)

# ============================================================================
# üéØ Main CLI Status and Help Commands
# ============================================================================

@app.command("status")
def system_status():
    """üéØ Show overall system status"""
    console.print(Panel("üéØ CNS Forge System Status", style="bold green"))
    
    # Check component health
    components = {
        "CNS Forge": check_forge_health(),
        "BitActor": check_bitactor_health(), 
        "Nuxt UI": check_nuxt_health(),
        "K8s Cluster": check_k8s_health(),
        "Database": check_db_health()
    }
    
    table = Table(title="System Health")
    table.add_column("Component", style="cyan")
    table.add_column("Status", style="green")
    table.add_column("Details", style="yellow")
    
    for component, (status, details) in components.items():
        status_icon = "‚úÖ" if status else "‚ùå"
        table.add_row(component, f"{status_icon} {'Running' if status else 'Down'}", details)
    
    console.print(table)

def check_forge_health():
    """Check if Phoenix server is running"""
    try:
        result = subprocess.run(["mix", "deps"], capture_output=True, cwd=FORGE_PATH)
        return True, "Dependencies OK"
    except:
        return False, "Mix not available"

def check_bitactor_health():
    """Check BitActor build status"""
    bitactor_binary = Path("bitactor_integrated_demo")
    if bitactor_binary.exists():
        return True, "Binaries built"
    return False, "Need to build"

def check_nuxt_health():
    """Check Nuxt setup"""
    package_json = Path("package.json")
    if package_json.exists():
        return True, "Node dependencies OK"
    return False, "No package.json"

def check_k8s_health():
    """Check K8s cluster connectivity"""
    try:
        result = subprocess.run(["kubectl", "cluster-info"], capture_output=True)
        return result.returncode == 0, "Cluster accessible" if result.returncode == 0 else "No cluster"
    except:
        return False, "kubectl not available"

def check_db_health():
    """Check database connectivity"""
    # Simplified check - would check actual DB in real implementation
    return True, "PostgreSQL OK"

@app.command("quickstart")
def quickstart():
    """üöÄ Quick start guide for new users"""
    console.print(Panel("üöÄ CNS Forge Quick Start", style="bold blue"))
    
    steps = [
        "1. Install dependencies: `cns forge deps`",
        "2. Compile the system: `cns forge compile`", 
        "3. Build BitActor: `cns bitactor build`",
        "4. Run tests: `cns test all`",
        "5. Start services: `cns forge start`",
        "6. Check status: `cns status`"
    ]
    
    for step in steps:
        console.print(f"  {step}")
    
    console.print("\nüí° For help with any command: `cns <command> --help`")

if __name__ == "__main__":
    app()