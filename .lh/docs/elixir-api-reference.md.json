{
    "sourceFile": "docs/elixir-api-reference.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753461713761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753461713761,
            "name": "Commit-0",
            "content": "# CNS Forge Elixir API Reference\n\n## Overview\n\nThis document provides a comprehensive API reference for all Elixir modules in the CNS Forge system, including function signatures, types, and usage examples.\n\n## Core Domain Module\n\n### CNSForge\n\n**Module**: `CNSForge`\n\n**Purpose**: Main domain module orchestrating the CNS Forge ecosystem.\n\n#### Functions\n\n##### `process_directive/2`\n\n```elixir\n@spec process_directive(String.t(), non_neg_integer()) :: \n  {:ok, map()} | {:error, :ttl_expired | term()}\n\n# Process a directive through the BitActor mesh\nCNSForge.process_directive(\"Create user with premium subscription\", 8)\n```\n\n**Parameters**:\n- `directive` (String.t()): High-level directive to process\n- `ttl` (non_neg_integer(), optional): Time-to-live budget (default: 8)\n\n**Returns**:\n- `{:ok, result}`: Successful processing with result\n- `{:error, :ttl_expired}`: TTL budget exhausted\n- `{:error, reason}`: Processing failure\n\n## BitActor Resource\n\n### CNSForge.BitActor\n\n**Module**: `CNSForge.BitActor`\n\n**Purpose**: Represents ephemeral, time-limited execution units.\n\n#### Types\n\n```elixir\n@type bit_actor_type :: :stimulus | :decoder | :workflow | :action\n@type bit_actor_status :: :pending | :running | :completed | :failed | :ttl_expired\n@type token :: map()\n@type ttl :: non_neg_integer()\n```\n\n#### Functions\n\n##### `create!/1`\n\n```elixir\n@spec create!(map()) :: CNSForge.BitActor.t()\n\n# Create a new BitActor\nCNSForge.BitActor.create!(%{\n  type: :stimulus,\n  transaction_id: \"abc123\",\n  token: %{directive: \"test\"},\n  ttl: 8\n})\n```\n\n**Parameters**:\n- `attrs` (map()): BitActor attributes\n\n**Returns**: `CNSForge.BitActor.t()` - Created BitActor\n\n##### `execute_hop!/2`\n\n```elixir\n@spec execute_hop!(CNSForge.BitActor.t(), map()) :: CNSForge.BitActor.t()\n\n# Execute one atomic hop\nCNSForge.BitActor.execute_hop!(bit_actor, %{\n  input_token: %{data: \"input\"},\n  operation: :process_data\n})\n```\n\n**Parameters**:\n- `bit_actor` (CNSForge.BitActor.t()): BitActor to execute\n- `attrs` (map()): Execution parameters\n\n**Returns**: `CNSForge.BitActor.t()` - Updated BitActor\n\n##### `fail!/2`\n\n```elixir\n@spec fail!(CNSForge.BitActor.t(), map()) :: CNSForge.BitActor.t()\n\n# Mark BitActor as failed\nCNSForge.BitActor.fail!(bit_actor, %{\n  error_message: \"Processing failed\"\n})\n```\n\n**Parameters**:\n- `bit_actor` (CNSForge.BitActor.t()): BitActor to fail\n- `attrs` (map()): Error details\n\n**Returns**: `CNSForge.BitActor.t()` - Failed BitActor\n\n##### `expire_ttl!/1`\n\n```elixir\n@spec expire_ttl!(CNSForge.BitActor.t()) :: CNSForge.BitActor.t()\n\n# Mark BitActor as TTL expired\nCNSForge.BitActor.expire_ttl!(bit_actor)\n```\n\n**Parameters**:\n- `bit_actor` (CNSForge.BitActor.t()): BitActor to expire\n\n**Returns**: `CNSForge.BitActor.t()` - Expired BitActor\n\n## Signal Resource\n\n### CNSForge.Signal\n\n**Module**: `CNSForge.Signal`\n\n**Purpose**: Immutable data payload for BitActor communication.\n\n#### Types\n\n```elixir\n@type signal_type :: atom()\n@type signal_priority :: :low | :medium | :high | :critical\n@type payload :: map()\n```\n\n#### Functions\n\n##### `emit!/1`\n\n```elixir\n@spec emit!(map()) :: CNSForge.Signal.t()\n\n# Emit a new signal\nCNSForge.Signal.emit!(%{\n  type: :data_ready,\n  source_actor_id: \"actor-123\",\n  transaction_id: \"tx-456\",\n  payload: %{result: \"processed\"},\n  ttl: 7,\n  target_actor_type: :workflow,\n  priority: :high\n})\n```\n\n**Parameters**:\n- `attrs` (map()): Signal attributes\n\n**Returns**: `CNSForge.Signal.t()` - Created signal\n\n##### `mark_routed!/1`\n\n```elixir\n@spec mark_routed!(CNSForge.Signal.t()) :: CNSForge.Signal.t()\n\n# Mark signal as routed\nCNSForge.Signal.mark_routed!(signal)\n```\n\n**Parameters**:\n- `signal` (CNSForge.Signal.t()): Signal to mark\n\n**Returns**: `CNSForge.Signal.t()` - Updated signal\n\n##### `mark_consumed!/1`\n\n```elixir\n@spec mark_consumed!(CNSForge.Signal.t()) :: CNSForge.Signal.t()\n\n# Mark signal as consumed\nCNSForge.Signal.mark_consumed!(signal)\n```\n\n**Parameters**:\n- `signal` (CNSForge.Signal.t()): Signal to mark\n\n**Returns**: `CNSForge.Signal.t()` - Updated signal\n\n## Telemetry Frame Resource\n\n### CNSForge.TelemetryFrame\n\n**Module**: `CNSForge.TelemetryFrame`\n\n**Purpose**: Universal observability and time-travel debugging.\n\n#### Functions\n\n##### `capture!/1`\n\n```elixir\n@spec capture!(map()) :: CNSForge.TelemetryFrame.t()\n\n# Capture a telemetry frame\nCNSForge.TelemetryFrame.capture!(%{\n  transaction_id: \"tx-123\",\n  bit_actor_id: \"actor-456\",\n  hop_sequence: 1,\n  operation: :process_data,\n  input_token: %{data: \"input\"},\n  output_token: %{result: \"output\"},\n  ttl_before: 8,\n  ttl_after: 7,\n  execution_time_us: 1500,\n  status: :success\n})\n```\n\n**Parameters**:\n- `attrs` (map()): Telemetry frame attributes\n\n**Returns**: `CNSForge.TelemetryFrame.t()` - Created frame\n\n##### `causal_chain/1`\n\n```elixir\n@spec causal_chain(String.t()) :: [CNSForge.TelemetryFrame.t()] | nil\n\n# Get complete causal chain for transaction\nCNSForge.TelemetryFrame.causal_chain(\"tx-123\")\n```\n\n**Parameters**:\n- `transaction_id` (String.t()): Transaction ID\n\n**Returns**: `[CNSForge.TelemetryFrame.t()]` - Causal chain frames\n\n##### `reconstruct_ttl_chain/1`\n\n```elixir\n@spec reconstruct_ttl_chain(String.t()) :: map()\n\n# Reconstruct TTL chain for debugging\nCNSForge.TelemetryFrame.reconstruct_ttl_chain(\"tx-123\")\n```\n\n**Parameters**:\n- `transaction_id` (String.t()): Transaction ID\n\n**Returns**: `map()` - TTL chain reconstruction\n\n##### `verify_chain_integrity/1`\n\n```elixir\n@spec verify_chain_integrity(String.t()) :: boolean()\n\n# Verify chain cryptographic integrity\nCNSForge.TelemetryFrame.verify_chain_integrity(\"tx-123\")\n```\n\n**Parameters**:\n- `transaction_id` (String.t()): Transaction ID\n\n**Returns**: `boolean()` - Integrity verification result\n\n## Application Supervision\n\n### CNSForge.Application\n\n**Module**: `CNSForge.Application`\n\n**Purpose**: Application supervision tree and system initialization.\n\n#### Callbacks\n\n##### `start/2`\n\n```elixir\n@callback start(Application.start_type(), term()) :: \n  {:ok, pid()} | {:error, term()}\n\n# Application start callback\n```\n\n##### `config_change/3`\n\n```elixir\n@callback config_change([{atom(), term()}], map(), [atom()]) :: :ok\n\n# Configuration change callback\n```\n\n### CNSForge.BitActorSupervisor\n\n**Module**: `CNSForge.BitActorSupervisor`\n\n**Purpose**: Dynamic supervisor for BitActor lifecycles.\n\n#### Functions\n\n##### `spawn_bit_actor/4`\n\n```elixir\n@spec spawn_bit_actor(atom(), String.t(), map(), non_neg_integer()) :: \n  {:ok, pid()} | {:error, term()}\n\n# Spawn a new BitActor process\nCNSForge.BitActorSupervisor.spawn_bit_actor(:stimulus, \"tx-123\", %{}, 8)\n```\n\n**Parameters**:\n- `type` (atom()): BitActor type\n- `transaction_id` (String.t()): Transaction ID\n- `token` (map()): Initial token\n- `ttl` (non_neg_integer()): TTL budget\n\n**Returns**:\n- `{:ok, pid()}`: Successfully spawned process\n- `{:error, reason}`: Spawn failure\n\n## Web Layer\n\n### CNSForgeWeb.Router\n\n**Module**: `CNSForgeWeb.Router`\n\n**Purpose**: Phoenix router for HTTP ingress and API endpoints.\n\n#### Routes\n\n```elixir\n# Directive processing\nPOST \"/api/directive\" → CNSForgeWeb.DirectiveController.process/2\n\n# Transaction tracing\nGET \"/api/trace/:transaction_id\" → CNSForgeWeb.DirectiveController.trace/2\n\n# Mesh status\nGET \"/api/mesh/status\" → CNSForgeWeb.MeshController.status/2\nGET \"/api/mesh/signals\" → CNSForgeWeb.MeshController.signals/2\n\n# Telemetry endpoints\nGET \"/api/telemetry/metrics\" → CNSForgeWeb.TelemetryController.metrics/2\nGET \"/api/telemetry/pulse\" → CNSForgeWeb.TelemetryController.pulse_logs/2\n```\n\n### CNSForgeWeb.DirectiveController\n\n**Module**: `CNSForgeWeb.DirectiveController`\n\n**Purpose**: HTTP ingress controller implementing stimulus BitActor.\n\n#### Functions\n\n##### `process/2`\n\n```elixir\n@spec process(Plug.Conn.t(), map()) :: Plug.Conn.t()\n\n# Process directive via HTTP\ndef process(conn, %{\"directive\" => directive} = params) do\n  ttl = Map.get(params, \"ttl\", 8)\n  # ... processing logic\nend\n```\n\n**Parameters**:\n- `conn` (Plug.Conn.t()): Phoenix connection\n- `params` (map()): Request parameters\n\n**Returns**: `Plug.Conn.t()` - Response connection\n\n##### `trace/2`\n\n```elixir\n@spec trace(Plug.Conn.t(), map()) :: Plug.Conn.t()\n\n# Trace transaction\ndef trace(conn, %{\"transaction_id\" => transaction_id}) do\n  # ... tracing logic\nend\n```\n\n**Parameters**:\n- `conn` (Plug.Conn.t()): Phoenix connection\n- `params` (map()): Request parameters\n\n**Returns**: `Plug.Conn.t()` - Response connection\n\n## Workflow Modules\n\n### CNSForge.Workflows.ProcessDirective\n\n**Module**: `CNSForge.Workflows.ProcessDirective`\n\n**Purpose**: Main Reactor workflow for directive processing.\n\n#### Workflow Steps\n\n```elixir\n# Step 1: Create stimulus BitActor\nstep :create_stimulus do\n  argument :directive_token, input(:directive_token)\n  run fn args, _context -> ... end\nend\n\n# Step 2: Parse directive\nstep :parse_directive do\n  argument :stimulus, result(:create_stimulus)\n  run fn args, _context -> ... end\n  compensate fn _error, args, _context -> ... end\nend\n\n# Step 3: Validate directive\nstep :validate_directive do\n  argument :parsed_result, result(:parse_directive)\n  run fn args, _context -> ... end\nend\n\n# Step 4: Route to workflow\nstep :route_to_workflow do\n  argument :validated_result, result(:validate_directive)\n  run fn args, _context -> ... end\nend\n\n# Step 5: Execute business logic\nstep :execute_business_logic do\n  argument :workflow_result, result(:route_to_workflow)\n  run fn args, _context -> ... end\nend\n```\n\n### CNSForge.Workflows.ComprehensiveCNSEcosystem\n\n**Module**: `CNSForge.Workflows.ComprehensiveCNSEcosystem`\n\n**Purpose**: Orchestrates complete CNS ecosystem using all ontologies.\n\n#### Workflow Steps\n\n```elixir\n# Step 1: Discover ontology universe\nstep :discover_ontology_universe do\n  argument :universe_config, input(:ontology_universe)\n  argument :ttl, input(:ttl)\n  run fn %{universe_config: config, ttl: ttl} -> ... end\nend\n\n# Step 2: Process ontology universe (Map)\nmap :process_ontology_universe do\n  source result(:discover_ontology_universe, [:discovered_files])\n  batch_size 25\n  allow_async? true\n  return :domain_bitactor_mesh\n  \n  step :parse_and_classify_ontology do\n    argument :ontology_file, element(:process_ontology_universe)\n    run fn %{ontology_file: file, ttl: ttl} -> ... end\n  end\n  \n  switch :compile_domain_mesh do\n    on result(:parse_and_classify_ontology)\n    \n    matches? &(&1.domain == :cybersecurity) do\n      compose :compile_cybersecurity_mesh, CNSForge.Workflows.CybersecurityThreatPipeline\n    end\n    \n    matches? &(&1.domain == :trading) do\n      compose :compile_trading_mesh, CNSForge.Workflows.TradingSemanticCompiler\n    end\n  end\nend\n```\n\n### CNSForge.Workflows.TradingSemanticCompiler\n\n**Module**: `CNSForge.Workflows.TradingSemanticCompiler`\n\n**Purpose**: Compiles trading domain ontologies into executable workflows.\n\n#### Workflow Steps\n\n```elixir\n# Step 1: Extract trading patterns\nstep :extract_trading_patterns do\n  argument :data, input(:semantic_data)\n  argument :ttl, input(:ttl)\n  run fn %{data: data, ttl: ttl} -> ... end\nend\n\n# Step 2: Compile instrument BitActors (Map)\nmap :compile_instrument_bitactors do\n  source result(:extract_trading_patterns, [:trading_patterns, :instruments])\n  allow_async? true\n  return :instrument_bitactor\n  \n  step :create_instrument_bitactor do\n    argument :instrument, element(:compile_instrument_bitactors)\n    run fn %{instrument: inst, ttl: ttl} -> ... end\n  end\nend\n\n# Step 3: Compile strategy BitActors (Switch)\nswitch :compile_strategy_bitactors do\n  on result(:extract_trading_patterns, [:trading_patterns, :strategies])\n  \n  matches? &has_algorithmic_strategies?/1 do\n    map :compile_algorithmic_strategies do\n      source result(:extract_trading_patterns, [:trading_patterns, :strategies])\n      allow_async? true\n      \n      step :create_algo_strategy_bitactor do\n        argument :strategy, element(:compile_algorithmic_strategies)\n        run fn %{strategy: strat} -> ... end\n      end\n    end\n  end\nend\n```\n\n### CNSForge.Workflows.CybersecurityThreatPipeline\n\n**Module**: `CNSForge.Workflows.CybersecurityThreatPipeline`\n\n**Purpose**: End-to-end cybersecurity threat detection and response.\n\n#### Workflow Steps\n\n```elixir\n# Step 1: Extract threat feeds (Streaming)\nstep :extract_threat_feeds do\n  argument :sources, input(:threat_feed_sources)\n  argument :ttl, input(:ttl)\n  max_retries 3\n  compensate fn reason, _args, _context, _options -> ... end\nend\n\n# Step 2: Validate threat quality\nstep :validate_threat_quality do\n  argument :raw_threats, result(:extract_threat_feeds)\n  argument :ttl, input(:ttl)\n  where fn %{raw_threats: threats} -> length(threats.items) > 0 end\nend\n\n# Step 3: Process threat batch (Map)\nmap :process_threat_batch do\n  source result(:extract_threat_feeds, [:threat_stream])\n  batch_size 100\n  allow_async? true\n  return :classify_threat\n  \n  step :parse_threat_indicators do\n    argument :threat_data, element(:process_threat_batch)\n    run fn %{threat_data: data, ttl: ttl} -> ... end\n  end\n  \n  step :enrich_threat_intel do\n    argument :parsed_threat, result(:parse_threat_indicators)\n    run &enrich_with_misp_feed/1\n    max_retries 2\n    compensate fn _reason, _args, _context, _options -> :ok end\n  end\n  \n  switch :classify_threat do\n    on result(:enrich_threat_intel)\n    \n    matches? &(&1.ioc_type == :malware_hash) do\n      step :classify_malware do\n        argument :threat, result(:enrich_threat_intel)\n        run fn %{threat: threat} -> ... end\n      end\n    end\n  end\nend\n```\n\n## Middleware Modules\n\n### CNSForge.ReactorMiddleware\n\n**Module**: `CNSForge.ReactorMiddleware`\n\n**Purpose**: Custom middleware for CNS Forge specific functionality.\n\n#### Functions\n\n##### `before_action/3`\n\n```elixir\n@spec before_action(Reactor.step(), map(), Reactor.context()) :: \n  {:ok, Reactor.step()} | {:error, term()}\n\n# Pre-execution middleware\n```\n\n##### `after_action/3`\n\n```elixir\n@spec after_action(Reactor.step(), map(), Reactor.context()) :: \n  {:ok, Reactor.step()} | {:error, term()}\n\n# Post-execution middleware\n```\n\n### CNSForge.SemanticMiddleware\n\n**Module**: `CNSForge.SemanticMiddleware`\n\n**Purpose**: Semantic reasoning middleware for ontology processing.\n\n#### Functions\n\n##### `parse_ontology/1`\n\n```elixir\n@spec parse_ontology(String.t()) :: {:ok, map()} | {:error, term()}\n\n# Parse TTL/RDF ontology\n```\n\n##### `validate_semantic/1`\n\n```elixir\n@spec validate_semantic(map()) :: {:ok, map()} | {:error, term()}\n\n# Validate semantic consistency\n```\n\n## Configuration\n\n### Mix Configuration\n\n**File**: `mix.exs`\n\n```elixir\ndefmodule CNSForge.MixProject do\n  use Mix.Project\n  \n  def project do\n    [\n      app: :cns_forge,\n      version: \"1.0.0\",\n      elixir: \"~> 1.15\",\n      start_permanent: Mix.env() == :prod,\n      deps: deps(),\n      aliases: aliases()\n    ]\n  end\n  \n  def application do\n    [\n      mod: {CNSForge.Application, []},\n      extra_applications: [:logger, :mnesia, :crypto]\n    ]\n  end\n  \n  defp deps do\n    [\n      {:ash, \"~> 3.0\"},\n      {:ash_postgres, \"~> 2.0\"},\n      {:reactor, \"~> 0.8\"},\n      {:phoenix, \"~> 1.7.0\"},\n      {:telemetry, \"~> 1.0\"},\n      {:jason, \"~> 1.2\"},\n      {:credo, \"~> 1.6\", only: [:dev, :test], runtime: false},\n      {:dialyxir, \"~> 1.0\", only: [:dev], runtime: false},\n      {:ex_doc, \"~> 0.27\", only: :dev, runtime: false}\n    ]\n  end\nend\n```\n\n## Error Handling\n\n### Error Types\n\n```elixir\n@type ttl_expired_error :: {:error, :ttl_expired}\n@type processing_error :: {:error, {:processing_failed, String.t()}}\n@type validation_error :: {:error, {:validation_failed, [String.t()]}}\n@type routing_error :: {:error, {:routing_failed, String.t()}}\n```\n\n### Error Handling Patterns\n\n```elixir\n# TTL validation\ncase ttl do\n  ttl when ttl <= 0 -> {:error, :ttl_expired}\n  _ -> {:ok, ttl}\nend\n\n# Saga compensation\ncompensate fn _error, args, _context ->\n  CNSForge.BitActor.fail!(args.stimulus, %{\n    error_message: \"Processing failed\"\n  })\nend\n\n# Graceful degradation\ncompensate fn _reason, _args, _context, _options ->\n  # Continue without enrichment on external service failure\n  :ok\nend\n```\n\n## Telemetry Events\n\n### Event Types\n\n```elixir\n# BitActor events\n[:cns_forge, :bit_actor, :hop]\n[:cns_forge, :bit_actor, :ttl_expired]\n[:cns_forge, :bit_actor, :compensate]\n[:cns_forge, :bit_actor, :undo]\n\n# Signal events\n[:cns_forge, :signal, :routed]\n[:cns_forge, :signal, :dropped]\n\n# Transaction events\n[:cns_forge, :transaction, :completed]\n```\n\n### Event Handlers\n\n```elixir\ndef handle_event([:cns_forge, :bit_actor, :hop], measurements, metadata, _config) do\n  IO.puts(\"\"\"\n  [PULSE] #{metadata.transaction_id} | #{metadata.step_name} | TTL: #{measurements.ttl_remaining} | #{measurements.execution_time_us}μs\n  \"\"\")\nend\n```\n\n## Performance Considerations\n\n### TTL Management\n\n```elixir\n# TTL validation pattern\nif ttl <= 0 do\n  {:error, :ttl_expired}\nelse\n  # Continue processing\n  {:ok, %{result: result, ttl: ttl - 1}}\nend\n```\n\n### Parallel Processing\n\n```elixir\n# Map step with parallel processing\nmap :process_items do\n  source input(:items)\n  allow_async? true\n  batch_size 25\n  \n  step :process_item do\n    argument :item, element(:process_items)\n    run fn %{item: item} -> ... end\n  end\nend\n```\n\n### Streaming Processing\n\n```elixir\n# Streaming with backpressure handling\nmap :process_stream do\n  source input(:data_stream)\n  batch_size 100\n  allow_async? true\n  \n  step :process_chunk do\n    argument :chunk, element(:process_stream)\n    run fn %{chunk: chunk} -> ... end\n  end\nend\n```\n\n---\n\n*This API reference provides comprehensive coverage of all Elixir modules in the CNS Forge system, including function signatures, types, and usage examples.* "
        }
    ]
}