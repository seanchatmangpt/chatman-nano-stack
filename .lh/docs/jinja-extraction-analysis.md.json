{
    "sourceFile": "docs/jinja-extraction-analysis.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753462098441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753462098441,
            "name": "Commit-0",
            "content": "# CNS Forge Jinja Extraction Analysis\n\n## Overview\n\nThis document analyzes all files in the CNS Forge project that reference Jinja templates, identifying which files need to extract, use, or integrate with the Jinja template system.\n\n## Files That Reference Jinja Templates\n\n### 1. Python Files (Core Template Engine)\n\n#### Primary Template Engines\n\n**`cns_forge_generator.py`** - Main CNS Forge Generator\n- **Purpose**: Leverages existing Jinja templates to generate production CNS Forge implementation\n- **Jinja Usage**: \n  - Imports: `from jinja2 import Environment, FileSystemLoader`\n  - Template References: 12+ template files\n  - Custom Filters: `c_identifier`, `upper_case`, `snake_case`\n- **Templates Used**:\n  - `bitactor/bitactor_erlang.j2`\n  - `ash_reactor_bitactor.j2`\n  - `bitactor/bitactor_c.j2`\n  - `bitactor/bitactor_python.j2`\n  - `k8s_deployment.yaml.j2`\n  - `k8s_service.yaml.j2`\n  - `k8s_configmap.yaml.j2`\n  - `terraform_aegis.tf.j2`\n  - `bitactor/bitactor_test_c.j2`\n  - `bitactor/bitactor_benchmark_c.j2`\n  - `makefile.j2`\n\n**`jinja_aot_compiler.py`** - AOT Compilation Engine\n- **Purpose**: Ahead-of-time Jinja2 compiler for performance optimization\n- **Jinja Usage**:\n  - Imports: `import jinja2`, `from jinja2 import Environment, DictLoader, Template, meta`\n  - AOT Compilation: Template pre-compilation and caching\n  - Performance: 10-50x improvement over runtime compilation\n- **Key Features**:\n  - Template caching with bytecode storage\n  - Custom filter registration\n  - Performance benchmarking\n  - Template metadata tracking\n\n**`dfls_semantic_codegen.py`** - DFLS Semantic Code Generator\n- **Purpose**: TTL/OWL/SHACL/SPARQL → Jinja Typer → Erlang/OTP Workflow\n- **Jinja Usage**:\n  - Imports: `import jinja2`, `from jinja2 import Environment, FileSystemLoader, select_autoescape`\n  - Integration: Uses existing `JinjaAOTCompiler`\n  - Custom Filters: Erlang-specific filters (`erlang_atom`, `erlang_string`, `erlang_module_name`)\n- **Templates Used**:\n  - GenServer templates\n  - Supervisor templates\n  - Erlang module templates\n\n#### Secondary Template Engines\n\n**`cns_forge_implementation.py`** - CNS Forge Implementation\n- **Purpose**: Implements CNS Forge with Jinja2 template generation\n- **Jinja Usage**:\n  - Imports: `from jinja2 import Environment, FileSystemLoader`\n  - Custom Filters: `c_identifier`\n- **Templates Used**:\n  - `bitactor/bitactor_c.j2`\n  - `terraform_aegis.tf.j2`\n  - `k8s_deployment.yaml.j2`\n\n**`aegis_ttl_template_engine.py`** - Aegis TTL Template Engine\n- **Purpose**: Generates all system components from TTL ontology using Jinja2 templates\n- **Jinja Usage**:\n  - Imports: `from jinja2 import Environment, FileSystemLoader, Template`\n  - Template Creation: Creates Jinja2 templates for BitActor C code\n\n**`ttl_to_nuxt_generator.py`** - TTL to Nuxt Generator\n- **Purpose**: Uses Jinja2 templates for 80/20 optimized code generation\n- **Jinja Usage**:\n  - Imports: `from jinja2 import Environment, FileSystemLoader`\n  - Frontend Generation: Nuxt.js components from TTL ontologies\n\n**`shacl_compiler.py`** - SHACL Compiler\n- **Purpose**: Compiles SHACL shapes into optimized C validation code using Jinja2\n- **Jinja Usage**:\n  - Imports: `import jinja2`, `from jinja2 import Environment, FileSystemLoader, Template`\n  - Template Environment: `Environment(loader=jinja2.DictLoader({}))`\n  - Custom Filters: SHACL-specific filters\n\n#### Testing and Benchmarking\n\n**`jinja_aot_benchmark.py`** - Jinja AOT Benchmark\n- **Purpose**: Comprehensive performance testing for Jinja AOT optimization\n- **Jinja Usage**:\n  - Imports: `from jinja2 import Environment, DictLoader`\n  - Integration: Uses `JinjaAOTCompiler`, `OWLTemplateCompiler`, `SHACLTemplateCompiler`\n  - Benchmarking: Performance comparison between runtime and AOT compilation\n\n**`test_owl_compiler_coverage.py`** - OWL Compiler Test Coverage\n- **Purpose**: Tests custom Jinja filters and template functionality\n- **Jinja Usage**:\n  - Imports: `from jinja2 import Environment, DictLoader`\n  - Test Functions: `test_custom_jinja_filters`, `test_adding_custom_jinja_filter`\n\n### 2. Elixir Files (Integration Layer)\n\n#### Production Reactor\n\n**`cns_forge_production_reactor.ex`** - Production Reactor Workflow\n- **Purpose**: Production CNS Forge reactor with Jinja template integration\n- **Jinja Usage**:\n  - Template Path: `jinja_templates: \"/Users/sac/cns/templates\"`\n  - Integration: Calls Python generator via `CNSForge.PythonBridge`\n  - Code Generation: Generates BitActor code using existing Jinja template infrastructure\n- **Key Integration Points**:\n  ```elixir\n  argument :jinja_templates, :string, allow_nil?: false\n  \n  generation_result = CNSForge.PythonBridge.call_generator(%{\n    parameters: input.decoded_params,\n    performance_targets: input.performance_targets,\n    template_path: input.jinja_templates,\n    ttl_budget: input.ttl_remaining\n  })\n  ```\n\n#### Generated Test Files\n\n**`generated/cns_forge_tdd_generated_tests.exs`** - Generated Test Suite\n- **Purpose**: TDD-generated tests including Jinja template testing\n- **Jinja Usage**:\n  - Test Function: `test_jinja_template_code_generation_tdd`\n  - Template Validation: Tests Jinja template existence at `templates/ash_reactor_bitactor.j2`\n\n### 3. Generated Files (Output)\n\n#### Generated C Files\nAll generated C files include Jinja references in headers:\n- **Pattern**: `* Generated by CNS Jinja AOT Compiler` or `* Compiler: OWL AOT Compiler with Jinja 1.0.0`\n- **Files**: 50+ generated C files across multiple directories\n- **Examples**:\n  - `generated/bytecode/cnsforge.c`\n  - `generated/cns_forge_8020/cns_forge_bitactor.c`\n  - `generated/bitactor/semantic_test.c`\n  - `live_system/uhft_core.c`\n\n#### Generated Erlang Files\nAll generated Erlang files include Jinja references in module headers:\n- **Pattern**: `%%% @copyright 2025 CNS - Generated by Jinja AOT`\n- **Files**: 10+ generated Erlang files\n- **Examples**:\n  - `generated/bitactor/semantic_bitactor.erl`\n  - `generated/cns_forge_8020/cns_forge_bitactor.erl`\n  - `generated/coverage_test/coverage_bitactor.erl`\n\n### 4. Configuration and Setup Files\n\n**`setup.py`** - Project Setup\n- **Purpose**: Project setup and dependency management\n- **Jinja Usage**:\n  - Dependency Check: `import rdflib, jinja2; print(\"Core deps OK\")`\n  - Ensures Jinja2 is available as a core dependency\n\n## Files That Need Jinja Template Extraction\n\n### 1. High Priority (Core Functionality)\n\n#### `cns_forge_generator.py`\n**Current State**: Uses 12+ hardcoded template paths\n**Extraction Needs**:\n- Template discovery and dynamic loading\n- Template validation and error handling\n- Template versioning and compatibility checking\n- Template dependency resolution\n\n#### `jinja_aot_compiler.py`\n**Current State**: AOT compilation with caching\n**Extraction Needs**:\n- Template source extraction from various locations\n- Template dependency graph construction\n- Template compilation pipeline optimization\n- Template cache invalidation strategies\n\n#### `dfls_semantic_codegen.py`\n**Current State**: Uses existing JinjaAOTCompiler\n**Extraction Needs**:\n- Template integration with semantic workflows\n- Template context generation from TTL ontologies\n- Template output validation and quality gates\n- Template performance monitoring\n\n### 2. Medium Priority (Integration Layer)\n\n#### `cns_forge_production_reactor.ex`\n**Current State**: Hardcoded template path\n**Extraction Needs**:\n- Dynamic template path resolution\n- Template availability validation\n- Template version compatibility checking\n- Template fallback mechanisms\n\n#### `cns_forge_implementation.py`\n**Current State**: Uses specific template files\n**Extraction Needs**:\n- Template selection based on implementation type\n- Template parameter validation\n- Template output post-processing\n- Template error recovery\n\n### 3. Low Priority (Testing and Validation)\n\n#### Test Files\n**Current State**: Test template existence\n**Extraction Needs**:\n- Template test data generation\n- Template output validation\n- Template performance benchmarking\n- Template regression testing\n\n## Template Extraction Requirements\n\n### 1. Template Discovery\n\n```python\ndef discover_templates(self) -> List[Path]:\n    \"\"\"Discover all Jinja templates in the project\"\"\"\n    templates = []\n    for template_file in self.templates_path.rglob(\"*.j2\"):\n        templates.append(template_file)\n    return templates\n```\n\n### 2. Template Validation\n\n```python\ndef validate_template(self, template_path: Path) -> bool:\n    \"\"\"Validate template syntax and dependencies\"\"\"\n    try:\n        with open(template_path, 'r') as f:\n            source = f.read()\n        self.env.parse(source)\n        return True\n    except Exception as e:\n        logger.error(f\"Template validation failed for {template_path}: {e}\")\n        return False\n```\n\n### 3. Template Context Generation\n\n```python\ndef generate_template_context(self, ontology: Dict) -> Dict[str, Any]:\n    \"\"\"Generate context for template rendering\"\"\"\n    return {\n        \"ontology_name\": ontology[\"name\"],\n        \"timestamp\": datetime.now().isoformat(),\n        \"signals\": self._extract_signals(ontology),\n        \"handlers\": self._extract_handlers(ontology),\n        \"config\": self._extract_config(ontology)\n    }\n```\n\n### 4. Template Dependency Resolution\n\n```python\ndef resolve_template_dependencies(self, template_path: Path) -> List[Path]:\n    \"\"\"Resolve template dependencies\"\"\"\n    dependencies = []\n    with open(template_path, 'r') as f:\n        source = f.read()\n    \n    # Extract include/extend statements\n    for line in source.split('\\n'):\n        if line.strip().startswith('{% include') or line.strip().startswith('{% extends'):\n            dep_path = self._extract_template_path(line)\n            if dep_path:\n                dependencies.append(dep_path)\n    \n    return dependencies\n```\n\n## Integration Points\n\n### 1. Elixir-Python Bridge\n\n```elixir\ndefmodule CNSForge.PythonBridge do\n  @moduledoc \"\"\"\n  Bridge to Python Jinja template engine\n  \"\"\"\n  \n  def call_generator(params) do\n    # Call Python generator with template parameters\n    System.cmd(\"python3\", [\n      \"cns_forge_generator.py\",\n      \"--params\", Jason.encode!(params.parameters),\n      \"--templates\", params.template_path,\n      \"--ttl\", Integer.to_string(params.ttl_budget)\n    ])\n  end\nend\n```\n\n### 2. Template Engine Integration\n\n```python\nclass CNSForgeTemplateEngine:\n    \"\"\"Unified template engine for CNS Forge\"\"\"\n    \n    def __init__(self, template_root: Path):\n        self.template_root = template_root\n        self.jinja_env = self._setup_jinja_environment()\n        self.aot_compiler = JinjaAOTCompiler()\n        self.templates = self._discover_templates()\n    \n    def generate_project(self, ontology: Dict, project_type: str) -> Dict[str, str]:\n        \"\"\"Generate complete project from ontology\"\"\"\n        context = self._generate_context(ontology)\n        templates = self._select_templates(project_type)\n        \n        files = {}\n        for template_name in templates:\n            content = self._render_template(template_name, context)\n            output_path = self._determine_output_path(template_name, project_type)\n            files[output_path] = content\n        \n        return files\n```\n\n## Performance Considerations\n\n### 1. Template Caching\n\n```python\ndef _cache_template(self, template_name: str, template_source: str):\n    \"\"\"Cache compiled template for performance\"\"\"\n    compiled = self.aot_compiler.compile_template(template_name, template_source)\n    self.template_cache[template_name] = compiled\n```\n\n### 2. Parallel Processing\n\n```python\ndef generate_parallel(self, templates: List[str], context: Dict) -> Dict[str, str]:\n    \"\"\"Generate templates in parallel\"\"\"\n    with ThreadPoolExecutor(max_workers=4) as executor:\n        future_to_template = {\n            executor.submit(self._render_template, template, context): template\n            for template in templates\n        }\n        \n        results = {}\n        for future in as_completed(future_to_template):\n            template = future_to_template[future]\n            results[template] = future.result()\n        \n        return results\n```\n\n## Error Handling and Recovery\n\n### 1. Template Not Found\n\n```python\ndef _handle_template_not_found(self, template_name: str) -> str:\n    \"\"\"Handle missing template with fallback\"\"\"\n    logger.warning(f\"Template {template_name} not found, using fallback\")\n    return self._generate_fallback_template(template_name)\n```\n\n### 2. Template Rendering Errors\n\n```python\ndef _handle_rendering_error(self, template_name: str, error: Exception) -> str:\n    \"\"\"Handle template rendering errors\"\"\"\n    logger.error(f\"Template rendering failed for {template_name}: {error}\")\n    return self._generate_error_template(template_name, error)\n```\n\n## Future Enhancements\n\n### 1. Template Versioning\n\n```python\ndef _check_template_version(self, template_path: Path) -> str:\n    \"\"\"Check template version and compatibility\"\"\"\n    # Extract version from template metadata\n    # Validate compatibility with current system\n    # Return version string\n```\n\n### 2. Template Composition\n\n```python\ndef _compose_templates(self, base_template: str, components: List[str]) -> str:\n    \"\"\"Compose templates from components\"\"\"\n    # Combine multiple templates into single output\n    # Handle template inheritance and composition\n    # Return composed template\n```\n\n---\n\n*This analysis provides a comprehensive overview of all files that reference Jinja templates in the CNS Forge project, identifying extraction needs and integration requirements for the template system.* "
        }
    ]
}