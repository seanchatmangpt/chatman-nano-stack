{
    "sourceFile": "docs/elixir-code-documentation.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1753461588810,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1753461588810,
            "name": "Commit-0",
            "content": "# CNS Forge Elixir Code Documentation\n\n## Overview\n\nCNS Forge is a sophisticated ecosystem composer built on the Ash/Reactor architecture, implementing a BitActor Mesh pattern for deterministic, observable, and fault-tolerant execution. The system translates high-level directives into atomic, time-limited execution units (BitActors) that communicate through immutable signals.\n\n## Architecture Principles\n\n- **TTL-Driven Execution**: All operations are bounded by a time-to-live (TTL) budget (default: 8 hops)\n- **Saga Orchestration**: Atomic transactions with compensation mechanisms\n- **Universal Observability**: Complete audit trail via telemetry frames\n- **Declarative Resources**: Ash Framework for resource-oriented architecture\n- **Signal-Based Communication**: Immutable data flow between BitActors\n\n## Project Structure\n\n```\nlib/\n├── cns_forge.ex                    # Main domain module\n├── cns_forge/\n│   ├── application.ex              # Application supervision tree\n│   ├── bit_actor.ex                # BitActor resource definition\n│   ├── signal.ex                   # Signal resource for routing\n│   ├── telemetry_frame.ex          # Observability resource\n│   ├── reactor_middleware.ex       # Reactor integration layer\n│   └── workflows/                  # Reactor workflow definitions\n│       ├── process_directive.ex    # Main directive processing\n│       ├── comprehensive_cns_ecosystem.ex\n│       ├── trading_semantic_compiler.ex\n│       ├── semantic_bitactor_mesh.ex\n│       └── cybersecurity_threat_pipeline.ex\n└── cns_forge_web/\n    ├── router.ex                   # Phoenix router\n    └── controllers/\n        └── directive_controller.ex # HTTP ingress controller\n```\n\n## Core Modules\n\n### CNSForge (lib/cns_forge.ex)\n\n**Purpose**: Main domain module that orchestrates the CNS Forge ecosystem.\n\n**Key Functions**:\n- `process_directive/2`: Entry point for directive processing\n- Resource definitions for BitActor, Signal, and TelemetryFrame\n\n**Architecture**:\n- Uses Ash.Domain for declarative resource management\n- Implements 8-hop TTL budget for execution\n- Generates cryptographically secure transaction IDs\n\n### CNSForge.Application (lib/cns_forge/application.ex)\n\n**Purpose**: Application supervision tree and system initialization.\n\n**Components**:\n- **SignalRegistry**: Registry for signal routing between BitActors\n- **MnesiaSetup**: Transactional state management setup\n- **TelemetrySupervisor**: Metrics collection and observability\n- **BitActorSupervisor**: Dynamic supervisor for BitActor lifecycles\n- **Phoenix Endpoint**: HTTP ingress for stimulus BitActors\n\n**Key Features**:\n- Mnesia table creation for Ash resources\n- Telemetry event handling for pulse logs\n- Dynamic BitActor process management\n- Saga compensation mechanisms\n\n### CNSForge.BitActor (lib/cns_forge/bit_actor.ex)\n\n**Purpose**: Represents ephemeral, time-limited execution units in the mesh.\n\n**Attributes**:\n- `type`: BitActor classification (:stimulus, :decoder, :workflow, :action)\n- `transaction_id`: Correlation ID for tracing\n- `ttl`: Remaining time-to-live in logical hops\n- `token`: Immutable state passed between hops\n- `status`: Current execution status\n- `result/error`: Output or failure information\n\n**Actions**:\n- `create`: Initialize new BitActor\n- `execute_hop`: Perform atomic operation and decrement TTL\n- `fail`: Mark BitActor as failed with error details\n- `expire_ttl`: Handle TTL exhaustion\n\n**Key Features**:\n- TTL validation before execution\n- Atomic hop execution with telemetry capture\n- Blake3 hash generation for integrity\n- Automatic status transitions\n\n### CNSForge.Signal (lib/cns_forge/signal.ex)\n\n**Purpose**: Immutable data payload for BitActor communication.\n\n**Attributes**:\n- `type`: Signal classification for routing\n- `source_actor_id`: Originating BitActor\n- `target_actor_type`: Destination BitActor type\n- `payload`: Immutable data content\n- `ttl`: Inherited TTL from source\n- `priority`: Routing priority level\n- `routed_at/consumed_at`: Timing metadata\n\n**Actions**:\n- `emit`: Create and route new signal\n- `mark_routed`: Confirm successful routing\n- `mark_consumed`: Record consumption by target\n\n**Key Features**:\n- Registry-based high-performance routing\n- Priority-based signal dispatch\n- Complete timing audit trail\n- Immutable payload design\n\n### CNSForge.TelemetryFrame (lib/cns_forge/telemetry_frame.ex)\n\n**Purpose**: Universal observability and time-travel debugging.\n\n**Attributes**:\n- `transaction_id`: Correlation ID\n- `bit_actor_id`: Source BitActor\n- `hop_sequence`: Sequential hop number\n- `operation`: Executed operation\n- `input_token/output_token`: State before/after\n- `ttl_before/ttl_after`: TTL state changes\n- `execution_time_us`: Performance metrics\n- `blake3_hash`: Integrity verification\n\n**Actions**:\n- `capture`: Record BitActor state transition\n- `causal_chain`: Retrieve complete transaction history\n- `reconstruct_ttl_chain`: Time-travel debugging\n- `verify_chain_integrity`: Cryptographic verification\n\n**Key Features**:\n- Complete audit trail for every operation\n- Time-travel debugging capabilities\n- Cryptographic integrity verification\n- Performance profiling data\n\n## Web Layer\n\n### CNSForgeWeb.Router (lib/cns_forge_web/router.ex)\n\n**Purpose**: Phoenix router for HTTP ingress and API endpoints.\n\n**Routes**:\n- `POST /api/directive`: Directive processing endpoint\n- `GET /api/trace/:transaction_id`: Transaction tracing\n- `GET /api/mesh/status`: BitActor mesh status\n- `GET /api/telemetry/metrics`: System metrics\n- `GET /api/telemetry/pulse`: Pulse logs\n\n**Features**:\n- JSON API with proper error handling\n- Development dashboard integration\n- Live telemetry monitoring\n\n### CNSForgeWeb.DirectiveController (lib/cns_forge_web/controllers/directive_controller.ex)\n\n**Purpose**: HTTP ingress controller implementing stimulus BitActor.\n\n**Endpoints**:\n- `process/2`: Process directives via Reactor workflow\n- `trace/2`: Retrieve complete causal chains\n\n**Features**:\n- Transaction ID generation\n- Processing time calculation\n- Comprehensive error handling\n- Time-travel debugging support\n\n## Workflow Layer\n\n### CNSForge.Workflows.ProcessDirective (lib/cns_forge/workflows/process_directive.ex)\n\n**Purpose**: Main Reactor workflow for directive processing.\n\n**Workflow Steps**:\n1. **create_stimulus**: Initialize stimulus BitActor\n2. **parse_directive**: Decode and parse directive\n3. **validate_directive**: Input validation\n4. **route_to_workflow**: Determine execution path\n5. **execute_business_logic**: Core business operations\n\n**Features**:\n- Saga orchestration with compensation\n- TTL validation at each step\n- Parallel execution where possible\n- Comprehensive error handling\n\n### Specialized Workflows\n\n#### Comprehensive CNS Ecosystem (lib/cns_forge/workflows/comprehensive_cns_ecosystem.ex)\n- **Purpose**: Orchestrates complex multi-domain operations\n- **Size**: 30KB, 688 lines\n- **Features**: Cross-domain coordination, advanced saga patterns\n\n#### Trading Semantic Compiler (lib/cns_forge/workflows/trading_semantic_compiler.ex)\n- **Purpose**: Financial trading directive processing\n- **Size**: 18KB, 554 lines\n- **Features**: Market data integration, risk management\n\n#### Semantic BitActor Mesh (lib/cns_forge/workflows/semantic_bitactor_mesh.ex)\n- **Purpose**: Semantic reasoning and knowledge graph operations\n- **Size**: 22KB, 592 lines\n- **Features**: Ontology processing, semantic routing\n\n#### Cybersecurity Threat Pipeline (lib/cns_forge/workflows/cybersecurity_threat_pipeline.ex)\n- **Purpose**: Security threat analysis and response\n- **Size**: 17KB, 527 lines\n- **Features**: Threat detection, automated response\n\n## Configuration\n\n### Mix Configuration (mix.exs)\n\n**Dependencies**:\n- **Ash Framework**: Resource-oriented architecture\n- **Reactor**: Workflow orchestration\n- **Phoenix**: HTTP framework\n- **Telemetry**: Observability\n- **Mnesia**: Transactional storage\n\n**Development Tools**:\n- **Credo**: Code quality analysis\n- **Dialyxir**: Static type checking\n- **ExDoc**: Documentation generation\n\n### Environment Configuration\n\n#### Development (config/dev.exs)\n- Live code reloading\n- Detailed logging\n- Development dashboard\n\n#### Production (config/prod.exs)\n- Optimized performance\n- Production telemetry\n- Security hardening\n\n## Data Layer\n\n### Mnesia Tables\n\n**bit_actor**:\n- Primary key: `id` (UUID)\n- Indexes: `transaction_id`, `type`\n- Disc copies for persistence\n\n**signal**:\n- Primary key: `id` (UUID)\n- Indexes: `transaction_id`, `target_actor_type`\n- Routing optimization\n\n**telemetry_frame**:\n- Primary key: `id` (UUID)\n- Indexes: `transaction_id`, `hop_sequence`\n- Audit trail optimization\n\n## Telemetry and Observability\n\n### Event Types\n- `[:cns_forge, :bit_actor, :hop]`: BitActor execution\n- `[:cns_forge, :bit_actor, :ttl_expired]`: TTL exhaustion\n- `[:cns_forge, :signal, :routed]`: Signal routing\n- `[:cns_forge, :transaction, :completed]`: Transaction completion\n\n### Pulse Logs\nReal-time execution traces showing:\n- Transaction ID correlation\n- Step-by-step execution\n- TTL consumption\n- Performance metrics\n\n## Security Features\n\n### Cryptographic Integrity\n- Blake3 hash generation for all state transitions\n- Chain integrity verification\n- Tamper-evident audit trails\n\n### Transaction Isolation\n- Mnesia transactional guarantees\n- Saga compensation mechanisms\n- Atomic operation boundaries\n\n## Performance Characteristics\n\n### TTL Budget Management\n- Default 8-hop limit per transaction\n- Configurable per directive\n- Automatic expiration handling\n\n### Signal Routing\n- Registry-based high-performance routing\n- Priority-based dispatch\n- Zero-copy immutable payloads\n\n### Memory Management\n- Ephemeral BitActor lifecycle\n- Automatic cleanup on completion\n- Mnesia garbage collection\n\n## Development Workflow\n\n### Code Quality\n- Credo for style and consistency\n- Dialyxir for type safety\n- Comprehensive test coverage\n\n### Documentation\n- ExDoc for API documentation\n- Inline documentation for all modules\n- Architecture decision records\n\n### Testing\n- Unit tests for all resources\n- Integration tests for workflows\n- Performance benchmarks\n\n## Deployment Considerations\n\n### Production Setup\n- Mnesia cluster configuration\n- Phoenix endpoint optimization\n- Telemetry aggregation\n\n### Monitoring\n- Live dashboard integration\n- Custom metrics collection\n- Alert configuration\n\n### Scaling\n- Horizontal scaling via Mnesia clustering\n- Load balancing for HTTP ingress\n- Signal routing optimization\n\n## Future Enhancements\n\n### Planned Features\n- Advanced saga patterns\n- Machine learning integration\n- Enhanced semantic reasoning\n- Cross-cluster coordination\n\n### Performance Optimizations\n- AOT compilation integration\n- Advanced caching strategies\n- Parallel execution optimization\n\n---\n\n*This documentation covers the complete Elixir codebase of CNS Forge, providing a comprehensive understanding of the BitActor Mesh architecture and its implementation.* "
        }
    ]
}